<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Coherence Spring Core</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script type="text/javascript">
function addBlockSwitches() {
	for (var primary of document.querySelectorAll('.primary')) {
		var switchItem = createSwitchItem(primary, createBlockSwitch(primary));
		switchItem.item.classList.add("selected");
		var title = primary.querySelector('.title')
		title.remove();
	}
	for (var secondary of document.querySelectorAll('.secondary')) {
		var primary = findPrimary(secondary);
		if (primary === null) {
			console.error("Found secondary block with no primary sibling");
		}
		else {
			var switchItem = createSwitchItem(secondary, primary.querySelector('.switch'));
			switchItem.content.classList.add("hidden");
			primary.append(switchItem.content);
			secondary.remove();
		}
	}
}

function createElementFromHtml(html) {
	var template = document.createElement('template');
    template.innerHTML = html;
    return template.content.firstChild;
}

function createBlockSwitch(primary) {
    var blockSwitch = createElementFromHtml('<div class="switch"></div>');
    primary.prepend(blockSwitch)
	return blockSwitch;
}

function findPrimary(secondary) {
	var candidate = secondary.previousElementSibling;
	while (candidate != null && !candidate.classList.contains('primary')) {
		candidate = candidate.previousElementSibling;
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	var blockName = block.querySelector('.title').textContent;
	var content = block.querySelectorAll('.content').item(0);
	var colist = block.querySelector('.colist')
	if (colist != null) {
		content.append();
	}
	var item = createElementFromHtml('<div class="switch--item">' + blockName + '</div>');
	item.dataset.blockName = blockName;
	content.dataset.blockName = blockName;
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	document.querySelectorAll(".switch--item").forEach(function(item) {
		var blockId = blockIdForSwitchItem(item);
		var handler = function(event) {
			selectedText = event.target.textContent;
			window.localStorage.setItem(blockId, selectedText);
			for (var switchItem of document.querySelectorAll(".switch--item")) {
				if (blockIdForSwitchItem(switchItem) === blockId && switchItem.textContent === selectedText) {
					select(switchItem);
				}
			}
		}
		item.addEventListener("click", handler);
		if (item.textContent === window.localStorage.getItem(blockId)) {
			select(item);
		}
	});
}

function select(selected) {
	for (var child of selected.parentNode.children) {
		child.classList.remove("selected");
	}
	selected.classList.add("selected");
	for (var child of selected.parentNode.parentNode.children) {
		if (child.classList.contains("content")) {
			if (selected.dataset.blockName === child.dataset.blockName) {
				child.classList.remove("hidden");
			}
			else {
				child.classList.add("hidden");
			}
		}
	}	
}

function blockIdForSwitchItem(item) {
	idComponents = []
	for (var switchItem of item.parentNode.querySelectorAll(".switch--item")) {
		idComponents.push(switchItem.textContent.toLowerCase());
	}
	return idComponents.sort().join("-")
}

window.onload = function() {
	addBlockSwitches();
	globalSwitch();
};
</script>

</head>
<body id="coherence-spring" class="book toc2 toc-left">
<div id="header">
<h1>Coherence Spring Core</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#coherence-spring-introduction">1. Getting Started</a></li>
<li><a href="#coherence-spring-botstrap">2. Bootstrapping Coherence</a></li>
<li><a href="#coherence-spring-botstrap-with-default-session">3. Using the Default Session</a></li>
<li><a href="#coherence-spring-botstrap-with-multiple-session">4. Configure Multiple Sessions</a></li>
<li><a href="#coherence-spring-bootstrap-session-config-properties">5. Session Configuration Bean Properties</a></li>
<li><a href="#coherence-spring-dependency-injection">6. Dependency Injection</a>
<ul class="sectlevel2">
<li><a href="#coherence-spring-dependency-injection-namedmap-namedcache">6.1. Injecting NamedMap and NamedCache</a>
<ul class="sectlevel3">
<li><a href="#coherence-spring-dependency-injection-type-conversion">6.1.1. Type Conversion of NamedMap and NamedCache</a></li>
<li><a href="#specify-the-mapcache-name">6.1.2. Specify the Map/Cache Name</a></li>
<li><a href="#specify-the-owning-session-name">6.1.3. Specify the Owning Session Name</a></li>
</ul>
</li>
<li><a href="#coherence-spring-dependency-injection-asyncnamedmap-asyncnamedcache">6.2. Injecting AsyncNamedMap &amp; AsyncNamedCache</a></li>
<li><a href="#coherence-spring-dependency-injection-views">6.3. Injecting Views (CQC)</a>
<ul class="sectlevel3">
<li><a href="#coherence-spring-dependency-injection-views-filter">6.3.1. Specify a View Filter</a></li>
<li><a href="#coherence-spring-dependency-injection-views-transformer">6.3.2. Specify a View Transformer</a></li>
</ul>
</li>
<li><a href="#coherence-spring-dependency-injection-session">6.4. Injecting a Session</a>
<ul class="sectlevel3">
<li><a href="#coherence-spring-dependency-injection-session-with-name">6.4.1. Specify a Session Name</a></li>
</ul>
</li>
<li><a href="#coherence-spring-dependency-injection-namedtopic">6.5. Injecting NamedTopic</a>
<ul class="sectlevel3">
<li><a href="#injecting-namedtopic">6.5.1. Injecting NamedTopic</a>
<ul class="sectlevel4">
<li><a href="#specify-the-topic-name">6.5.1.1. Specify the Topic Name</a></li>
<li><a href="#specify-the-session-name">6.5.1.2. Specify the Session Name</a></li>
</ul>
</li>
<li><a href="#injecting-a-namedtopic-publisher">6.5.2. Injecting a NamedTopic Publisher</a>
<ul class="sectlevel4">
<li><a href="#specify-the-topic-name-2">6.5.2.1. Specify the Topic Name</a></li>
<li><a href="#specify-the-owning-session">6.5.2.2. Specify the Owning Session</a></li>
</ul>
</li>
<li><a href="#injecting-a-namedtopic-subscriber">6.5.3. Injecting a NamedTopic Subscriber</a>
<ul class="sectlevel4">
<li><a href="#specify-the-topic-name-3">6.5.3.1. Specify the Topic Name</a></li>
<li><a href="#specify-the-owning-session-2">6.5.3.2. Specify the Owning Session</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#coherence-spring-events">7. Events</a>
<ul class="sectlevel2">
<li><a href="#coherence-spring-events-mapevent-listeners">7.1. MapEvent Listeners</a>
<ul class="sectlevel3">
<li><a href="#mapevent-observer-methods">7.1.1. MapEvent Observer Methods</a>
<ul class="sectlevel4">
<li><a href="#specify-the-mapcache-name-2">7.1.1.1. Specify the Map/Cache name</a></li>
<li><a href="#specify-the-cache-service-name">7.1.1.2. Specify the Cache Service name</a></li>
<li><a href="#specify-the-owning-session-name-2">7.1.1.3. Specify the Owning Session Name</a></li>
</ul>
</li>
<li><a href="#coherence-spring-events-mapevent-listeners-specific-events">7.1.2. Receive Specific Event Types</a></li>
<li><a href="#coherence-spring-events-mapevent-listeners-filtering-events">7.1.3. Filtering Events</a></li>
<li><a href="#coherence-spring-events-mapevent-listeners-transforming-events">7.1.4. Transforming Events</a></li>
</ul>
</li>
<li><a href="#coherence-spring-events-event-interceptors">7.2. Coherence Event Interceptors</a>
<ul class="sectlevel3">
<li><a href="#event-types">7.2.1. Event Types</a></li>
<li><a href="#coherence-lifecycle-events">7.2.2. Coherence Lifecycle Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-lifecycleevent-types">7.2.2.1. Receive Specific LifecycleEvent Types</a></li>
<li><a href="#receive-coherencelifecycleevents-for-a-specific-coherence-instance">7.2.2.2. Receive CoherenceLifecycleEvents for a Specific Coherence Instance</a></li>
</ul>
</li>
<li><a href="#session-lifecycle-events">7.2.3. Session Lifecycle Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-sessionlifecycleevent-types">7.2.3.1. Receive Specific SessionLifecycleEvent Types</a></li>
<li><a href="#receive-sessionlifecycleevents-for-a-specific-session-instance">7.2.3.2. Receive SessionLifecycleEvents for a Specific Session Instance</a></li>
</ul>
</li>
<li><a href="#configurablecachefactory-lifecycle-events">7.2.4. ConfigurableCacheFactory Lifecycle Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-coherencelifecycleevent-types">7.2.4.1. Receive Specific CoherenceLifecycleEvent Types</a></li>
<li><a href="#receive-coherencelifecycleevents-for-a-specific-coherence-instance-2">7.2.4.2. Receive CoherenceLifecycleEvents for a Specific Coherence Instance</a></li>
</ul>
</li>
<li><a href="#cache-lifecycle-events">7.2.5. Cache Lifecycle Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-cachelifecycleevent-types">7.2.5.1. Receive Specific CacheLifecycleEvent Types</a></li>
<li><a href="#receive-cachelifecycleevents-for-a-specific-namedmap-or-namedcache">7.2.5.2. Receive CacheLifecycleEvents for a Specific NamedMap or NamedCache</a></li>
<li><a href="#receive-cachelifecycleevents-from-a-specific-cache-service">7.2.5.3. Receive CacheLifecycleEvents from a Specific Cache Service</a></li>
<li><a href="#receive-cachelifecycleevents-from-a-specific-session">7.2.5.4. Receive CacheLifecycleEvents from a Specific Session</a></li>
</ul>
</li>
<li><a href="#entry-events">7.2.6. Entry Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-entryevent-types">7.2.6.1. Receive Specific EntryEvent Types</a></li>
<li><a href="#receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache">7.2.6.2. Receive EntryProcessorEvents for a Specific NamedMap or NamedCache</a></li>
<li><a href="#receive-entryprocessorevents-from-a-specific-cache-service">7.2.6.3. Receive EntryProcessorEvents from a Specific Cache Service</a></li>
<li><a href="#receive-entryprocessorevents-from-a-specific-session">7.2.6.4. Receive EntryProcessorEvents from a Specific Session</a></li>
</ul>
</li>
<li><a href="#entryprocessor-events">7.2.7. EntryProcessor Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-entryprocessorevent-types">7.2.7.1. Receive Specific EntryProcessorEvent Types</a></li>
<li><a href="#receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache-2">7.2.7.2. Receive EntryProcessorEvents for a Specific NamedMap or NamedCache</a></li>
<li><a href="#receive-entryprocessorevents-from-a-specific-cache-service-2">7.2.7.3. Receive EntryProcessorEvents from a Specific Cache Service</a></li>
<li><a href="#receive-entryprocessorevents-from-a-specific-session-2">7.2.7.4. Receive EntryProcessorEvents from a Specific Session</a></li>
</ul>
</li>
<li><a href="#partition-level-transaction-events">7.2.8. Partition Level Transaction Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-transactionevent-types">7.2.8.1. Receive Specific TransactionEvent Types</a></li>
<li><a href="#receive-transactionevent-from-a-specific-cache-service">7.2.8.2. Receive TransactionEvent from a Specific Cache Service</a></li>
</ul>
</li>
<li><a href="#partition-transfer-events">7.2.9. Partition Transfer Events</a>
<ul class="sectlevel4">
<li><a href="#receive-specific-transferevent-types">7.2.9.1. Receive Specific TransferEvent Types</a></li>
<li><a href="#receive-transferevent-from-a-specific-cache-service">7.2.9.2. Receive TransferEvent from a Specific Cache Service</a></li>
</ul>
</li>
<li><a href="#unsolicited-commit-events">7.2.10. Unsolicited Commit Events</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#coherence-spring-filter-binding-annotations">8. Filter Binding Annotations</a>
<ul class="sectlevel2">
<li><a href="#create-the-filter-binding-annotation">8.1. Create the filter binding annotation</a></li>
<li><a href="#create-the-filterfactory">8.2. Create the <code>FilterFactory</code></a></li>
<li><a href="#annotate-the-injection-point">8.3. Annotate the Injection Point</a></li>
</ul>
</li>
<li><a href="#coherence-spring-extractor-binding-annotations">9. Extractor Binding Annotations</a>
<ul class="sectlevel2">
<li><a href="#create-the-extractor-binding-annotation">9.1. Create the extractor binding annotation</a></li>
<li><a href="#create-the-extractorfactory">9.2. Create the <code>ExtractorFactory</code></a></li>
<li><a href="#annotate-the-injection-point-2">9.3. Annotate the Injection Point</a></li>
</ul>
</li>
<li><a href="#coherence-spring-messaging-with-coherence-topics">10. Messaging with Coherence Topics</a>
<ul class="sectlevel2">
<li><a href="#define-publishers-coherencepublisher">10.1. Define Publishers - @CoherencePublisher</a></li>
<li><a href="#reactive-and-non-blocking-method-definitions">10.2. Reactive and Non-Blocking Method Definitions</a>
<ul class="sectlevel3">
<li><a href="#mono-value-and-return-type">10.2.1. Mono Value and Return Type</a></li>
<li><a href="#reactor-flux-value-and-return-type">10.2.2. Reactor Flux Value and Return Type</a></li>
<li><a href="#future-return-type">10.2.3. Future Return Type</a></li>
</ul>
</li>
<li><a href="#define-subscribers-coherencetopiclistener">10.3. Define Subscribers - @CoherenceTopicListener</a></li>
<li><a href="#method-parameter-bindings">10.4. Method Parameter Bindings</a></li>
<li><a href="#committing-messages">10.5. Committing Messages</a>
<ul class="sectlevel3">
<li><a href="#default-commit-behaviour">10.5.1. Default Commit Behaviour</a></li>
<li><a href="#setting-commit-strategy">10.5.2. Setting Commit Strategy</a></li>
<li><a href="#forwarding-messages-with-sendto">10.5.3. Forwarding Messages with @SendTo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#coherence-spring-cachestore">11. Cache Store</a>
<ul class="sectlevel2">
<li><a href="#coherence-spring-cachestore-demo">11.1. JPA Repository CacheStore Demo</a>
<ul class="sectlevel3">
<li><a href="#coherence-spring-cachestore-demo-model">11.1.1. Data Model</a></li>
<li><a href="#coherence-spring-cachestore-demo-jpa-repository">11.1.2. Writing a JPA Repository CacheStore</a></li>
<li><a href="#coherence-spring-cachestore-demo-embedded">11.1.3. Embedded Coherence</a></li>
<li><a href="#coherence-spring-cachestore-demo-running-embedded">11.1.4. Running the Embedded Sample</a></li>
<li><a href="#coherence-spring-cachestore-demo-coherence-extend">11.1.5. Using Coherence*Extend</a></li>
<li><a href="#coherence-spring-cachestore-demo-inspect-database">11.1.6. Inspecting the Database</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This section dives into the Coherence Spring Core module. Coherence Spring Core
provides the basic support for the <a href="https://spring.io/projects/spring-framework/">Spring Framework</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-introduction"><a class="anchor" href="#coherence-spring-introduction"></a>1. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To add support for Oracle Coherence to an existing Spring Framework project, you should first add the required Spring
Coherence dependencies to your build configuration:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Coherence Spring Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.oracle.coherence.spring&lt;/groupId&gt;
    &lt;artifactId&gt;coherence-spring-core&lt;/artifactId&gt;
    &lt;version&gt;4.0.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation("com.oracle.coherence.spring:coherence-spring-core:4.0.0-SNAPSHOT")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Next you also need to add the version of Coherence that your application will be using. Coherence Spring is compatible
with both the open source Coherence CE and the commercial version of Oracle Coherence. Therefore, we don&#8217;t bring in
Oracle Coherence as transitive dependency. For example, to use Coherence CE specify:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Oracle Coherence CE Dependency</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt;
    &lt;artifactId&gt;coherence&lt;/artifactId&gt;
    &lt;version&gt;23.03&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation("com.oracle.coherence.ce:coherence:23.03")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to use the commercial version of Coherence:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Commercial Oracle Coherence Dependency</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.oracle.coherence&lt;/groupId&gt;
    &lt;artifactId&gt;coherence&lt;/artifactId&gt;
    &lt;version&gt;14.1.1.2206&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation("com.oracle.coherence.ce:coherence:14.1.1.2206")</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Coherence CE versions are available from Maven Central. The commercial versions of Coherence needs to be uploaded
into your own Maven repository.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Coherence Spring requires as a minimum version <strong>Coherence CE</strong> <code>22.06</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-botstrap"><a class="anchor" href="#coherence-spring-botstrap"></a>2. Bootstrapping Coherence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coherence Spring uses the Coherence bootstrap API introduced in Coherence CE <code>20.12</code> to
configure and create Coherence instances. This means that Coherence resources in a Spring application are typically
part of a Coherence Session.</p>
</div>
<div class="paragraph">
<p>By default, Coherence will start a single Session configured to use the default Coherence configuration file. This
behavior can easily be configured using traditional Coherence using system properties or using dedicated configuration.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-botstrap-with-default-session"><a class="anchor" href="#coherence-spring-botstrap-with-default-session"></a>3. Using the Default Session</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main building block for setting up Coherence for Spring is the <code>@EnableCoherence</code> annotation. This annotation will
import the <code>CoherenceSpringConfiguration</code> class under the covers. Therefore, you can alternatively also declare
<code>@Import(CoherenceSpringConfiguration.class)</code> instead.</p>
</div>
<div class="paragraph">
<p>In most use-cases, only a single Coherence Session is expected to be used. Therefore, without providing any further
configuration the default session is configured using the embedded default configuration file. This results in the application
joining Coherence as a cluster member (Session type <code>SERVER</code>). This is of course not the only way. Coherence Spring support
the following 3 session types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>SERVER</strong> - Join as Coherence cluster member. This is the default session type.</p>
</li>
<li>
<p><strong>CLIENT</strong> - Connect to Coherence as a Coherence*Extend client</p>
</li>
<li>
<p><strong>GRPC</strong> - Connect to Coherence as gRPC client</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the application is a Coherence cluster member, or a Coherence*Extend client, then all that needs to be specified is
the Coherence configuration file name. For instance, you may for example provide an implementation of
the <code>AbstractSessionConfigurationBean</code>, to specify the type of your session and to use a custom Coherence configuration
file.</p>
</div>
<div class="listingblock">
<div class="title">SessionConfigurationBean</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> @Bean
 SessionConfigurationBean sessionConfigurationBeanDefault() {
     final SessionConfigurationBean sessionConfigurationBean =
             new SessionConfigurationBean();
     sessionConfigurationBean.setType(SessionType.SERVER);
     sessionConfigurationBean.setConfig("test-coherence-config.xml");
     return sessionConfigurationBean;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you connect as gRPC client, however, the properties change slightly and you need to specify a
<code>GrpcSessionConfigurationBean</code>:</p>
</div>
<div class="listingblock">
<div class="title">GrpcSessionConfigurationBean</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> @Bean
 GrpcSessionConfigurationBean grpcSessionConfigurationBean() {
     final GrpcSessionConfigurationBean sessionConfigurationBean = new GrpcSessionConfigurationBean();
     sessionConfigurationBean.setName("sessionName");
     sessionConfigurationBean.setChannelName("grpcChanelBeanName");
     return sessionConfigurationBean;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Channel Name property would refer to a grpcChannel bean.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-botstrap-with-multiple-session"><a class="anchor" href="#coherence-spring-botstrap-with-multiple-session"></a>4. Configure Multiple Sessions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you need to configure multiple Coherence sessions, simply define multiple <code>SessionConfigurationBeans</code>. The auto-configuration
will pick those up automatically to configure the required sessions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>default</code> session will only exist when zero sessions are specifically configured, or the default session is
specifically configured with the default session name.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-bootstrap-session-config-properties"><a class="anchor" href="#coherence-spring-bootstrap-session-config-properties"></a>5. Session Configuration Bean Properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Depending on the session type the available properties change a bit. The following properties all to ALL session types.</p>
</div>
<div class="paragraph">
<p><strong>name</strong></p>
</div>
<div class="paragraph">
<p>The name of the session. If not set, it will be set to the default session name which is an empty String.</p>
</div>
<div class="paragraph">
<p><strong>scopeName</strong></p>
</div>
<div class="paragraph">
<p>A scope name is typically used in an application where the Coherence cluster member has multiple sessions. The scope
name is used to keep the sessions separate. The scope name will be applied to the session’s underlying
<em>ConfigurableCacheFactory</em> and used to scope Coherence services. In this way multiple session configurations may use
identical service names, which will be kept separate using the scope. On a Coherence cluster member, each session should
have a unique scope name.</p>
</div>
<div class="paragraph">
<p><strong>type</strong></p>
</div>
<div class="paragraph">
<p>The session type of this configuration. There are three different types of sessions that can be configured:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>server</strong> represents storage enabled cluster member session.</p>
</li>
<li>
<p><strong>client</strong> represents a storage disabled cluster member or Coherence*Extend client session.</p>
</li>
<li>
<p><strong>grpc</strong> is a gRPC client session (see the gRPC documentation).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The type of the session affects how the bootstrap API starts the session.</p>
</div>
<div class="paragraph">
<p><strong>priority</strong></p>
</div>
<div class="paragraph">
<p>The priority specifies the order to use, when starting the session. Sessions will be started with the lowest priority
first. If this property is not specified, the property will default to <code>0</code>.</p>
</div>
<div class="paragraph">
<p>The following property applies to the <code>CLIENT</code> (Coherence*Extend) and <code>Server</code> mode, only:</p>
</div>
<div class="paragraph">
<p><strong>configUri</strong></p>
</div>
<div class="paragraph">
<p>The Coherence cache configuration URI for the session. As already mentioned, the most common configuration to set will
be the Coherence configuration file name. If not specified, the default value will be <code>coherence-cache-config.xml</code>.</p>
</div>
<div class="paragraph">
<p>The following property applies to the <code>GRPC</code> mode, only:</p>
</div>
<div class="paragraph">
<p><strong>channelName</strong></p>
</div>
<div class="paragraph">
<p>Sets the underlying gRPC channel. If not set, it will default to <code>localhost</code> and port <code>1408</code>.</p>
</div>
<div class="paragraph">
<p><strong>serializer</strong></p>
</div>
<div class="paragraph">
<p>Specifies the serializer to that shall be used, in order to serialize gRPC message payloads. If not specified,
the serializer will be the default Coherence serializer, either POF if it has been enabled with the <code>coherence.pof.enabled</code>
system property or Java serialization.</p>
</div>
<div class="paragraph">
<p><strong>tracingEnabled</strong></p>
</div>
<div class="paragraph">
<p>Specifies if client gRPC tracing should be enabled. This is <code>false</code> by default.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-dependency-injection"><a class="anchor" href="#coherence-spring-dependency-injection"></a>6. Dependency Injection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coherence Spring provides comprehensive support for the injection Coherence objects into your Spring beans including:
<code>Session</code>, <code>NamedMap</code>, <code>NamedCache</code>, <code>ContinuousQueryCache</code>, <code>ConfigurableCacheFactory</code>, <code>Cluster</code>.</p>
</div>
<div class="paragraph">
<p>For the most part, you can use the equivalent Coherence Spring annotation that match the annotations from Coherence&#8217;s CDI
or Micronaut support.</p>
</div>
<div class="sect2">
<h3 id="coherence-spring-dependency-injection-namedmap-namedcache"><a class="anchor" href="#coherence-spring-dependency-injection-namedmap-namedcache"></a>6.1. Injecting NamedMap and NamedCache</h3>
<div class="paragraph">
<p>Coherence <code>NamedMap</code> and <code>NamedCache</code> instances can be injected as beans in Spring applications. The mechanics of injecting
<code>NamedMap</code> or <code>NamedCache</code> beans is identical, so any use of <code>NamedCache</code> in the examples below can be replaced with <code>NamedMap</code>.
Other more specialized forms of <code>NamedMap</code> and <code>NamedCache</code> can also be injected, for example the asynchronous forms of
both classes and views.</p>
</div>
<div class="paragraph">
<p>In Spring one caveat exists regarding the injection of Map-based classes that directly inherit from <code>java.util.Map</code>
including <code>NamedCache</code> and <code>NamedMap</code> when using the <code>@Autowired</code> annotation. Instead of injecting actual instances of
Beans representing a <code>java.util.Collection</code> or <code>java.util.Map</code>, Spring will inject a collection of all the beans that
represent the specified bean type instead. As a work-around, you can use the <code>@Resource</code> annotation, but it has its own
limitations, for instance, not being usable for constructor injection.</p>
</div>
<div class="listingblock">
<div class="title">Example of using the @Resource annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Resource(name = COHERENCE_CACHE_BEAN_NAME)
    private NamedCache numbers;                  <i class="conum" data-value="1"></i><b>(1)</b>

    @Resource(name = COHERENCE_CACHE_BEAN_NAME)
    @Name("numbers")                             <i class="conum" data-value="2"></i><b>(2)</b>
    private NamedCache namedCache;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If not specified, the name of the field will be used to determine the cache name</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Alternatively, you can specify the name of the cache using the <code>@Name</code> annotation</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For more information, please see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-qualifiers">Fine-tuning
Annotation-based Autowiring with Qualifiers</a> in the Spring Framework reference guide.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to provide a better user-experience around the dependency injection of maps and caches, Coherence Spring introduces its
own set of annotations. The following annotations are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@CoherenceCache</p>
</li>
<li>
<p>@CoherenceMap</p>
</li>
<li>
<p>@CoherenceAsyncCache</p>
</li>
<li>
<p>@CoherenceAsyncMap</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using these annotations, you can inject any Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedMap.html">NamedMap</a> and
<a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedCache.html">NamedCache</a> in any situation including constructors.</p>
</div>
<div class="paragraph">
<p>Furthermore, the annotations also give you some added conveniences such as the ability to specify the name of the cache, or
the name of the Coherence session as part of the annotation. E.g., the above example can be simplified to:</p>
</div>
<div class="listingblock">
<div class="title">Example of using the  @CoherenceCache annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceCache
    private NamedCache numbers;                  <i class="conum" data-value="1"></i><b>(1)</b>

    @CoherenceCache("numbers")                   <i class="conum" data-value="2"></i><b>(2)</b>
    private NamedCache namedCache;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If not specified, the name of the field will be used to determine the cache name</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Alternatively, you can specify the name of the cache using the <code>@Name</code> annotation</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All the annotations <code>@CoherenceCache</code>, <code>@CoherenceMap</code>, <code>@CoherenceAsyncCache</code>, and <code>@CoherenceAsyncMap</code> are themselves
annotated with <code>@Lazy</code>. This is to avoid deadlocks where a cache bean requires another bean to be injected in its
configuration, which will happen on a different thread to the main Spring thread. A consequence of this is that all
cache beans will be Spring lazy dynamic proxies.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="coherence-spring-dependency-injection-type-conversion"><a class="anchor" href="#coherence-spring-dependency-injection-type-conversion"></a>6.1.1. Type Conversion of NamedMap and NamedCache</h4>
<div class="paragraph">
<p>As mentioned previously, Spring a has a special relationship with Map implementations. In order to work around this
limitation, we provide the meta-annotations <code>@CoherenceCache</code>, <code>@CoherenceMap</code> etc. We apply a little trick using the
<code>@Value</code> annotation and referencing the injection candidate via a <code>SpEL</code> expression. This in turn, however, triggers type
conversion in Spring&#8217;s <code>DefaultListableBeanFactory</code>, and we must provide a no-op converter for Map-based Coherence objects
using the <code>CoherenceGenericConverter</code>.</p>
</div>
<div class="paragraph">
<p>Without it, you may see Spring&#8217;s <code>MapToMapConverter</code> being used, which in turn will call <code>Map#entrySet()</code>, a potentially
very expensive operation for large datasets in a Coherence cluster.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When defining your own <code>ConversionService</code> bean, please make sure that the <code>CoherenceGenericConverter</code> is added to it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the <code>BeanFactory</code> already contains a <code>ConfigurableConversionService</code>, we will add the <code>CoherenceGenericConverter</code> automatically
using the <code>CoherenceConversionServicePostProcessor</code>. This should be typically the case with Spring Boot, which provides
the <code>ApplicationConversionService</code>. If you provide your own <code>ConversionService</code> bean, we will back-off and a message to
add the <code>CoherenceGenericConverter</code> manually will be logged.</p>
</div>
<div class="listingblock">
<div class="title">Manually adding the <code>CoherenceGenericConverter</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService =
            new DefaultFormattingConversionService();
        conversionService.addConverter(new CoherenceGenericConverter());   <i class="conum" data-value="1"></i><b>(1)</b>
        return conversionService;
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a new instance of the CoherenceGenericConverter</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In case no <code>ConversionService</code> is defined in your application context, PropertyEditors are being used, and that chain
does not seem to trigger the same expensive operation, nonetheless using the <code>ConversionService</code> route is advised.</p>
</div>
</div>
<div class="sect3">
<h4 id="specify-the-mapcache-name"><a class="anchor" href="#specify-the-mapcache-name"></a>6.1.2. Specify the Map/Cache Name</h4>
<div class="paragraph">
<p>As already mentioned above, you specify the name of the map/cache using the value-property of the annotation. Of course,
the same applies when injecting a constructor or method parameter:</p>
</div>
<div class="listingblock">
<div class="title">Example of constructor injection of a NamedMap</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class SomeService {

    public SomeService(@CoherenceMap("people") NamedMap&lt;String, Person&gt; map) {
        // TODO: initialize the service...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If injecting a cache/map via the constructor, AND you do not specify a cache/map name, then Coherence Spring
will try to derive the name of the cache/map from the parameter name. However, this only works if either the compiler flag
<code>-parameters</code> (Java 8+) is enabled, or if the JVM generates debugging info. For more information see the
article <a href="https://www.baeldung.com/java-parameter-reflection">Method Parameter Reflection in Java</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you prefer, you can also specify the name of the map/cache using the <code>@Name</code> annotation. The example below will inject a
<code>NamedMap</code> that uses an underlying cache named people:</p>
</div>
<div class="listingblock">
<div class="title">Example of using the @Name annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceMap
@Name("people")
private NamedMap&lt;String, Person&gt; map;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specify-the-owning-session-name"><a class="anchor" href="#specify-the-owning-session-name"></a>6.1.3. Specify the Owning Session Name</h4>
<div class="paragraph">
<p>Whilst most applications probably use a single Coherence Session, there are uses-cases where an application may have
multiple sessions. In this case, when injecting for example a <code>NamedMap</code>, the specific session can be specified by
annotating the injection point with either <code>@SessionName</code> or more concise with the <code>session</code> parameter available for the
following annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@CoherenceCache</p>
</li>
<li>
<p>@CoherenceMap</p>
</li>
<li>
<p>@CoherenceAsyncCache</p>
</li>
<li>
<p>@CoherenceAsyncMap</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the previous examples where no separate <code>Session</code> name was specified, Coherence will use the default session to obtain the
caches/maps. Assuming that the application has multiple sessions configured, one of which is named <em>Catalog</em>, the
following example injects a <code>NamedMap</code> from an underlying cache named <em>products</em> in the <em>Catalog</em> session.</p>
</div>
<div class="listingblock">
<div class="title">Example of using the @SessionName annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceMap
@SessionName("Catalog")
@Name("products")
private NamedMap&lt;String, Product&gt; map;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be further streamlined to:</p>
</div>
<div class="listingblock">
<div class="title">Example of using the @CoherenceMap annotation with the session parameter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceMap(name="products", session="Catalog")
private NamedMap&lt;String, Product&gt; map;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same annotation can be used on method parameter injection points as well:</p>
</div>
<div class="listingblock">
<div class="title">Example of using @CoherenceMap with session parameter in a constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class CatalogController {

    public CatalogController(@CoherenceMap(name="products", session="Catalog")
                             NamedMap&lt;String, Product&gt; products) {
        // TODO: initialize the bean...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-dependency-injection-asyncnamedmap-asyncnamedcache"><a class="anchor" href="#coherence-spring-dependency-injection-asyncnamedmap-asyncnamedcache"></a>6.2. Injecting AsyncNamedMap &amp; AsyncNamedCache</h3>
<div class="paragraph">
<p>It is possible to inject the asynchronous classes <code>AsyncNamedMap</code> and <code>AsyncNamedCache</code> as beans in exactly the same way as
described above. Just change the type of the injection point to be <code>AsyncNamedMap</code> or <code>AsyncNamedCache</code> using one of
the following annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@CoherenceAsyncCache</p>
</li>
<li>
<p>@CoherenceAsyncMap</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Injecting an AsyncNamedMap</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceAsyncMap("people")
private AsyncNamedMap&lt;String, Person&gt; map;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-dependency-injection-views"><a class="anchor" href="#coherence-spring-dependency-injection-views"></a>6.3. Injecting Views (CQC)</h3>
<div class="paragraph">
<p>View (or <a href="https://coherence.community/23.03/api/java/com/tangosol/net/cache/ContinuousQueryCache.html">ContinuousQueryCache</a>) beans can be injected by
specifying the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/View.html">@View</a> annotation at the injection
point. A view is a sub-set of the data in an underlying cache, controlled by a
<a href="https://coherence.community/23.03/api/java/com/tangosol/util/Filter.html">Filter</a>.</p>
</div>
<div class="listingblock">
<div class="title">Injecting an AsyncNamedMap</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceMap("people")
@View                                            <i class="conum" data-value="1"></i><b>(1)</b>
private NamedMap&lt;String, Person&gt; map;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The injection point has been annotated with <code>@View</code>, so the injected <code>NamedMap</code> will actually be an implementation
of a <code>ContinuousQueryCache</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the above example, no <code>Filter</code> has been specified, so the default behaviour is to use an
<a href="https://coherence.community/23.03/api/java/com/tangosol/util/filter/AlwaysFilter.html">AlwaysFilter</a>. This means that the view will contain all the
entries from the underlying cache (typically a distributed cache). As a <code>ContinuousQueryCache</code> will hold keys and values
locally in deserialized form, this can often be a better approach than using a replicated cache.</p>
</div>
<div class="sect3">
<h4 id="coherence-spring-dependency-injection-views-filter"><a class="anchor" href="#coherence-spring-dependency-injection-views-filter"></a>6.3.1. Specify a View Filter</h4>
<div class="paragraph">
<p>Filters are specified for views using a special filter binding annotation. These are annotations that are themselves
annotated with the meta-annotation <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/FilterBinding.html">@FilterBinding</a>.
Coherence Spring comes with some built in implementations, for example
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/AlwaysFilter.html">@AlwaysFilter</a> and
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/WhereFilter.html">@WhereFilter</a>. It is simple to
implement custom Filters as required by applications (see the <a href="#create-the-filter-binding-annotation">Filter Binding Annotation section</a>
for more details).</p>
</div>
<div class="paragraph">
<p>For example, if there was a cache named "people", containing <code>Person</code> instances, and the application required a view of
that cache to just contain <code>People</code> where the "lastName" attribute is equal to "Simpson", then the <code>@WhereFilter</code> filter binding
annotation could be used to specify the <code>Filter</code>. The <code>@WhereFilter</code> annotation produces a <code>Filter</code> created from a Coherence
CohQL where-clause, in this case <code>lastName == 'Simpson'</code>.</p>
</div>
<div class="listingblock">
<div class="title">Injecting a @CoherenceMap with @WhereFilter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceMap("people")                                  <i class="conum" data-value="1"></i><b>(1)</b>
    @View                                                    <i class="conum" data-value="2"></i><b>(2)</b>
    @WhereFilter("lastName = 'Simpson'")                     <i class="conum" data-value="3"></i><b>(3)</b>
    private NamedMap&lt;String, Person&gt; allSimpsons;            <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The name of the underlying map for the view is "people".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@View</code> annotation specifies that a view will be injected rather than a raw`NamedMap`.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@WhereFilter</code> annotation specifies the CohQL expression.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>NamedMap</code> contains only people with the last name <code>Simpson</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The above CohQL expression is still rather simple. Let&#8217;s further restrict the results:</p>
</div>
<div class="listingblock">
<div class="title">@WhereFilter with a more complex CohQL expression</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceMap("people")
    @View
    @WhereFilter("lastName = 'Simpson' and age &gt; 10")        <i class="conum" data-value="1"></i><b>(1)</b>
    private NamedMap&lt;String, Person&gt; simpsons;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The @WhereFilter also filters on the <code>age</code> property.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The view injected above will be all People with a <code>lastName</code> attribute equal to <code>Simpson</code> and an <code>age</code> attribute
greater than <code>10</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Coherence reference guide has an in-depth chapter on CohQL and more details on the <em>WHERE</em> clause under
<a href="https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.2206/develop-applications/using-coherence-query-language.html#GUID-B671FDD9-386B-4719-BFC6-DCFF32C360BA">Filtering Entries in a Result Set</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Other built-in or custom filter binding annotations can be combined as well and multiple filter-binding annotations can
be added to the same injection point to build up more complex views. The Filter instances produced from each filter
binding annotation will all be collected together in an <a href="https://coherence.community/23.03/api/java/com/tangosol/util/filter/AllFilter.html">AllFilter</a>,
which will logically combine them together.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-dependency-injection-views-transformer"><a class="anchor" href="#coherence-spring-dependency-injection-views-transformer"></a>6.3.2. Specify a View Transformer</h4>
<div class="paragraph">
<p>The values in a view map do not have to be the same as the values in the underlying cache. Instead, a ValueExtractor can be used
to transform the actual cache value into a different value in the view. ValueExtractors are specified for views using a
special extractor binding annotation. These are annotations that are themselves annotated with the meta-annotation
@ExtractorBinding. The Coherence Spring framework comes with some built in implementations, for example @PropertyExtractor,
and it is simple to implement other as required by applications (see the Extractor Binding Annotation section for more details).</p>
</div>
<div class="paragraph">
<p>For example, if there was a cache named "people", containing Person instances, and the application required a view where
the value was just the age attribute of each Person rather than the whole cache value. A @PropertyExtractor annotation
could be used to specify that the values should be transformed using a property extractor.</p>
</div>
<div class="listingblock">
<div class="title">Injecting a @CoherenceMap with multiple @WhereFilter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceMap("people")                                  <i class="conum" data-value="1"></i><b>(1)</b>
    @View                                                    <i class="conum" data-value="2"></i><b>(2)</b>
    @PropertyExtractor("age")                                <i class="conum" data-value="3"></i><b>(3)</b>
    private NamedMap&lt;String, Integer&gt; ages;                  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The name of the underlying map for the view is "people".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@View</code> annotation specifies that a view will be injected rather than a raw <code>NamedMap</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@PropertyExtractor</code> annotation specifies that a <code>ValueExtractor</code> should be used to transform the underlying cache
values into different values in the view. In this case the <code>@PropertyExtractor</code> annotation will produce a value extractor
to extract the <code>age</code> property.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Note that the map injected is now a <code>NamedMap&lt;String, Integer&gt;</code> with generic types of <code>String</code> and <code>Integer</code> because
the values have been transformed from <code>Person</code> to <code>Integer</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Multiple extractor bindings can be applied to the injection point, in which case the view value will be a <code>List</code> of the
extracted attributes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-dependency-injection-session"><a class="anchor" href="#coherence-spring-dependency-injection-session"></a>6.4. Injecting a Session</h3>
<div class="paragraph">
<p>Sometimes it might not be possible to inject a Coherence resource, such as <code>NamedMap</code> or <code>NamedCache</code> directly because
the name of the resource to be injected is not known until runtime. In this case it makes sense to inject a <code>Session</code>
instance which can then be used to obtain other resources.</p>
</div>
<div class="paragraph">
<p>The simplest way to inject a <code>Session</code> is to annotate a field, method parameter, or other injection point with your preferred
Spring-supported injection annotation such as <code>@Autowired</code> or <code>@Inject</code>:</p>
</div>
<div class="listingblock">
<div class="title">Injecting a Coherence Session instance</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class MyBean {
    @Inject                                      <i class="conum" data-value="1"></i><b>(1)</b>
    private Session session;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Other injection annotations such as <code>@Autowired</code> can be used as well</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Injecting a Coherence Session using constructor injection</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class MyBean {
    @Autowired                                   <i class="conum" data-value="1"></i><b>(1)</b>
    public MyBean(Session session) {
        // TODO...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If your class has only a single constructor, you can even omit the <code>@Autowired</code> annotation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both examples above will inject the default <code>Session</code> instance into the injection point.</p>
</div>
<div class="sect3">
<h4 id="coherence-spring-dependency-injection-session-with-name"><a class="anchor" href="#coherence-spring-dependency-injection-session-with-name"></a>6.4.1. Specify a Session Name</h4>
<div class="paragraph">
<p>For most applications that only use a single <code>Session</code> the simple examples above will be all that is required. Some
applications though may use multiple named Session instances, in which case the <code>Session</code> name need to be specified. This
can be done by adding the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation to
the injection point.</p>
</div>
<div class="listingblock">
<div class="title">Injecting a specific (named) Coherence Session</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class MyBean {
    @Autowired                                   <i class="conum" data-value="1"></i><b>(1)</b>
    @Name("Catalog")
    private Session session;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Other injection annotations such as <code>@Inject</code> can be used as well</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>or into a constructor:</p>
</div>
<div class="listingblock">
<div class="title">Injecting a specific (named) Coherence Session via constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class MyBean {
    @Autowired                                   <i class="conum" data-value="1"></i><b>(1)</b>
    public MyBean(@Name("Catalog") Session session) {
        // TODO...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If your class has only a single constructor, you can even omit the <code>@Autowired</code> annotation</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-dependency-injection-namedtopic"><a class="anchor" href="#coherence-spring-dependency-injection-namedtopic"></a>6.5. Injecting NamedTopic</h3>
<div class="paragraph">
<p>Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/NamedTopic.html">NamedTopic</a>
instances can be injected as beans in Spring applications.</p>
</div>
<div class="paragraph">
<p>An alternative way to write message driven applications instead of directly injecting <code>NamedTopic</code>, <code>Publisher</code> or <code>Subscriber</code> beans is to use <a href="#coherence-spring-messaging-with-coherence-topics">Messaging with Coherence Topics</a>.</p>
</div>
<div class="sect3">
<h4 id="injecting-namedtopic"><a class="anchor" href="#injecting-namedtopic"></a>6.5.1. Injecting NamedTopic</h4>
<div class="paragraph">
<p>The simplest way to inject a <code>NamedTopic</code> is to just annotate the injection point with <code>@javax.inject.Inject</code>.</p>
</div>
<div class="listingblock">
<div class="title">Inject NamedTopic</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
private NamedTopic&lt;Person&gt; people;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the injection point field name is used to determine the topic name to inject,
so a <code>NamedTopic</code> bean with an underlying topic name of <code>people</code> will be injected.</p>
</div>
<div class="paragraph">
<p>As an alternative to using a <code>NamedTopic</code> directly in code, Coherence Spring also supports annotating methods directly as publishers and subscribers. See the <a href="#coherence-spring-messaging-with-coherence-topics">Messaging with Coherence Topics</a> section of the documentation.</p>
</div>
<div class="sect4">
<h5 id="specify-the-topic-name"><a class="anchor" href="#specify-the-topic-name"></a>6.5.1.1. Specify the Topic Name</h5>
<div class="paragraph">
<p>Sometimes the name of the topic being injected needs to be different to the injection point name.
This is always the case when injecting into method parameters as the parameter names are lost by the time the injection point is processed. In this case we can use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a>
annotation to specify the underlying cache name.</p>
</div>
<div class="paragraph">
<p>The example below will inject a <code>NamedTopic</code> that uses an underlying topic named <code>orders</code>.</p>
</div>
<div class="listingblock">
<div class="title">Use @Name to specify topic name</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Name("people")
private NamedTopic&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies when injecting a constructor or method parameter:</p>
</div>
<div class="listingblock">
<div class="title">Use @Name to specify topic name on a parameter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Singleton
public class SomeBean {
    @Inject
    public SomeBean(@Name("orders") NamedTopic&lt;Order&gt; topic) {
    // ToDo:
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-session-name"><a class="anchor" href="#specify-the-session-name"></a>6.5.1.2. Specify the Session Name</h5>
<div class="paragraph">
<p>Whilst most applications probably use a single Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/net/Session.html">Session</a> there are uses-cases where an application may
have multiple sessions. In this case, when injecting a <code>NamedTopic</code> the specific session can be specified
by annotating the injection point with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a>.</p>
</div>
<div class="paragraph">
<p>In the previous examples where no <code>@SessionName</code> was specified Coherence will use the default session to obtain the caches.</p>
</div>
<div class="paragraph">
<p>For example, assume the application has multiple sessions configured, one of which is named <code>Customers</code>.
The following code snippet injects a <code>NamedTopic</code> using an underlying topic named <code>orders</code> in the <code>Customers</code> session.</p>
</div>
<div class="listingblock">
<div class="title">Use @SessionName to specify session</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@SessionName("Customers")
@Name("orders")
private NamedTopic&lt;Order&gt; topic;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the same annotation can be used on method parameter injection points.</p>
</div>
<div class="listingblock">
<div class="title">Use @SessionName to specify session on a method parameter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OrderProcessor {
    @Inject
    public OrderProcessor(@SessionName("Customers") @Name("orders")
                          NamedTopic&lt;Order&gt; orders) {
        // ToDo:
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injecting-a-namedtopic-publisher"><a class="anchor" href="#injecting-a-namedtopic-publisher"></a>6.5.2. Injecting a NamedTopic Publisher</h4>
<div class="paragraph">
<p>If application code only needs to publish messages to a Coherence <code>NamedTopic</code> then instead of injecting a
<code>NamedTopic</code> bean, a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Publisher.html">Publisher</a> bean can be injected.</p>
</div>
<div class="paragraph">
<p>The simplest way to inject a <code>Publisher</code> is just to annotate the injection point of type <code>Publisher</code> with <code>@Inject</code>,
for example:</p>
</div>
<div class="listingblock">
<div class="title">Inject a Publisher</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
private Publisher&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above will inject a <code>Publisher</code> bean, the name of the underlying <code>NamedTopic</code> will be taken from the
name of the injection point, in this case <code>orders</code>.</p>
</div>
<div class="sect4">
<h5 id="specify-the-topic-name-2"><a class="anchor" href="#specify-the-topic-name-2"></a>6.5.2.1. Specify the Topic Name</h5>
<div class="paragraph">
<p>If the name of the injection point cannot be used as the <code>NamedTopic</code> name, which is always the case with injection points that are method or constructor parameters, then the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation can be used to specify the topic name.</p>
</div>
<div class="paragraph">
<p>For example, both of the code snippets below inject a <code>Publisher</code> that published to the <code>orders</code> topic:</p>
</div>
<div class="listingblock">
<div class="title">Inject a Publisher that publishes on the <code>orders</code> topic</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Name("orders")
private Publisher&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Inject a Publisher that publishes on the <code>orders</code> topic</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OrderController {
    @Inject
    public OrderController(@Name("orders") Publisher&lt;Order&gt; topic) {
        // ToDo:
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-owning-session"><a class="anchor" href="#specify-the-owning-session"></a>6.5.2.2. Specify the Owning Session</h5>
<div class="paragraph">
<p>As with injection of <code>NamedTopics</code>, in applications using multiple <code>Session</code> instances, the name of the <code>Session</code> that
owns the underlying <code>NamedTopic</code> can be specified when injecting a <code>Publisher</code> by adding the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="listingblock">
<div class="title">Inject a Publisher while specifying the owning session</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Name("orders")
@SessionName("Customers")
private Publisher&lt;Order&gt; orders;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injecting-a-namedtopic-subscriber"><a class="anchor" href="#injecting-a-namedtopic-subscriber"></a>6.5.3. Injecting a NamedTopic Subscriber</h4>
<div class="paragraph">
<p>If application code only needs to subscribe to messages from a Coherence <code>NamedTopic</code> then instead of injecting a
<code>NamedTopic</code> bean, a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Subscriber.html">Subscriber</a> bean can be injected.</p>
</div>
<div class="paragraph">
<p>The simplest way to inject a <code>Subscriber</code> is just to annotate the injection point of type <code>Subscriber</code> with <code>@Inject</code>,
for example:</p>
</div>
<div class="listingblock">
<div class="title">Inject Subscriber</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
private Subscriber&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above will inject a <code>Subscriber</code> bean, the name of the underlying <code>NamedTopic</code> will be taken from the
name of the injection point, in this case <code>orders</code>.</p>
</div>
<div class="sect4">
<h5 id="specify-the-topic-name-3"><a class="anchor" href="#specify-the-topic-name-3"></a>6.5.3.1. Specify the Topic Name</h5>
<div class="paragraph">
<p>If the name of the injection point cannot be used as the <code>NamedTopic</code> name, which is always the case with injection points that are method or constructor parameters, then the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation can be used to specify the topic name.</p>
</div>
<div class="paragraph">
<p>For example, both of the code snippets below inject a <code>Subscriber</code> that subscribe to the <code>orders</code> topic:</p>
</div>
<div class="listingblock">
<div class="title">Inject subscriber into field</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Name("orders")
private Subscriber&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Inject subscriber into method parameter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
public class OrderController {
    @Inject
    public OrderController(@Name("orders") Subscriber&lt;Order&gt; topic) {
        // ToDo:
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-owning-session-2"><a class="anchor" href="#specify-the-owning-session-2"></a>6.5.3.2. Specify the Owning Session</h5>
<div class="paragraph">
<p>As with injection of <code>NamedTopics</code>, in applications using multiple <code>Session</code> instances, the name of the <code>Session</code> that
owns the underlying <code>NamedTopic</code> can be specified when injecting a <code>Subscriber</code> by adding the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@Name("orders")
@SessionName("Customers")
private Subscriber&lt;Order&gt; orders;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-events"><a class="anchor" href="#coherence-spring-events"></a>7. Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Event driven patterns are a common way to build scalable applications and microservices. Coherence produces a number of
events that can be used by applications to respond to data changes and other actions in Coherence.</p>
</div>
<div class="paragraph">
<p>There are two types of events in Coherence:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/util/MapEvent.html">MapEvents</a> which are subscribed to using a <a href="https://coherence.community/23.03/api/java/com/tangosol/util/MapListener.html">MapListener</a></p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/Event.html">Events</a>, which are subscribed to using an <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/EventInterceptor.html">EventInterceptor</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring makes subscribing to both of these event-types much simpler using observer methods annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.</p>
</div>
<div class="listingblock">
<div class="title">Example of using a Coherence Event Listener</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
void onEvent(CoherenceLifecycleEvent event) {
    // TODO: process event...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method above receives all events of type <code>CoherenceLifecycleEvent</code> emitted during the lifetime of the application. The
actual events received can be controlled further by annotating the method or the method arguments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring <code>4.2</code> introduced
<a href="https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2">Annotation-driven event listeners</a> as
part of its <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events">event support</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Coherence Spring does <strong>NOT</strong> directly use Spring&#8217;s <code>ApplicationEvent</code> class and the corresponding <code>ApplicationListener</code>
interface. However, Coherence Spring follows that pattern conceptually in order to provide a similar user experience.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the handling of Coherence events is asynchronous. Use the <code>@Synchronous</code> annotation to make the
event handler execution synchronous.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example of making a Coherence Event Listener synchronous</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
@Synchronous
void onEvent(CoherenceLifecycleEvent event) {
    // TODO: process event...
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-events-mapevent-listeners"><a class="anchor" href="#coherence-spring-events-mapevent-listeners"></a>7.1. MapEvent Listeners</h3>
<div class="paragraph">
<p>Listening for changes to data in Coherence is a common use case in applications. Typically, this involves creating an
implementation of a <a href="https://coherence.community/23.03/api/java/com/tangosol/util/MapListener.html">MapListener</a> and adding that listener to a
<code>NamedMap</code> or <code>NamedCache</code>. Using Coherence Spring makes this much simpler by just using Spring beans with suitably
annotated observer methods that will receive the respective events.</p>
</div>
<div class="sect3">
<h4 id="mapevent-observer-methods"><a class="anchor" href="#mapevent-observer-methods"></a>7.1.1. MapEvent Observer Methods</h4>
<div class="paragraph">
<p>A <a href="https://coherence.community/23.03/api/java/com/tangosol/util/MapEvent.html">MapEvent</a> observer method is a method on a Spring bean that is
annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The annotated method must have a <code>void</code> return type and must take a single method parameter of type <code>MapEvent</code>, typically
this has the generic types of the underlying map/cache key and value.</p>
</div>
<div class="paragraph">
<p>For example, assuming that there is a map/cache named <code>people</code>, with keys of type <code>String</code> and values of type <code>Plant</code>,
and the application has logic that should be executed each time a new <code>Plant</code> is inserted into the map:</p>
</div>
<div class="listingblock">
<div class="title">Example of listening to Inserted events</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.event.Inserted;
import com.oracle.coherence.spring.annotation.event.MapName;
import com.oracle.coherence.spring.event.CoherenceEventListener;
import com.tangosol.util.MapEvent;
import org.springframework.stereotype.Component;

@Component                                       <i class="conum" data-value="1"></i><b>(1)</b>
public class PersonEventHandler {

    @CoherenceEventListener                      <i class="conum" data-value="2"></i><b>(2)</b>
    public void onNewPerson(@MapName("people")   <i class="conum" data-value="3"></i><b>(3)</b>
                            @Inserted            <i class="conum" data-value="4"></i><b>(4)</b>
                            MapEvent&lt;String, Person&gt; event) {
        // TODO: process the event
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>PersonController</code> is a simple Spring bean, in this case a <code>Controller</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>onNewPerson</code> method is annotated with <code>@CoherenceEventListener</code> making it a Coherence event listener.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@MapName("people")</code> annotation specifies the name of the map to receive events from, in this case <code>people</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>@Inserted</code> annotation specified that only <code>Inserted</code> events should be sent to this method.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The above example is still rather simple. There are a number of other annotations that provide much finer-grained control
over what events are received from where.</p>
</div>
<div class="sect4">
<h5 id="specify-the-mapcache-name-2"><a class="anchor" href="#specify-the-mapcache-name-2"></a>7.1.1.1. Specify the Map/Cache name</h5>
<div class="paragraph">
<p>By default, a <code>MapEvent</code> observer method would receive events for all maps/caches. In practice though, this would not be
a very common use case, and typically you would want an observer method to listen to events that are for specific caches.
The Coherence Spring API contains two annotations for specifying the map name:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/MapName.html">@MapName</a></p>
</li>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/CacheName.html">@CacheName</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both annotations take a single <code>String</code> value that represents the name of the map or cache that events should be received
from.</p>
</div>
<div class="listingblock">
<div class="title">Listening to events for all caches</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onEvent(MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above method receives events for <em>all</em> caches.</p>
</div>
<div class="listingblock">
<div class="title">Listening to events for the map named "foo"</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onFooEvent(@MapName("foo")       <i class="conum" data-value="1"></i><b>(1)</b>
                           MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the map named <code>foo</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listening to events for the cache named "bar"</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onBarEvent(@CacheName("bar")     <i class="conum" data-value="1"></i><b>(1)</b>
                           MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the cache named <code>bar</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-cache-service-name"><a class="anchor" href="#specify-the-cache-service-name"></a>7.1.1.2. Specify the Cache Service name</h5>
<div class="paragraph">
<p>In the previous section we showed to restrict received events to a specific map or cache name. Events can also be restricted
to only events from a specific <a href="https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.2206/develop-applications/introduction-coherence-clusters.html#GUID-62A54E60-E964-4DFE-BE7F-CA7ADA93354E">cache service</a>.
In Coherence all caches are owned by a cache service, which has a unique name. By default, a <code>MapEvent</code> observer method
would receive events for a matching cache name on <em>all</em> services. If an applications Coherence configuration has multiple
services, the events can be restricted to just specific services using the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="listingblock">
<div class="title">Listening to events for the "foo" map on all services</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onEventFromAllServices(@MapName("foo")  <i class="conum" data-value="1"></i><b>(1)</b>
                                MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the map named <code>foo</code> on <em>all</em> cache services.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listening to events for the "foo" map on the "Storage" service only</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onEventOnStorageService(@MapName("foo")
                        @ServiceName("Storage")  <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the map named <code>foo</code> owned by the cache service named <code>Storage</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listening to events for ALL caches on the "Storage" service</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onEventFromAllCachesOnStorageService(@ServiceName("Storage")  <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for <em>all</em> caches owned by the cache service named <code>Storage</code> as there is no <code>@MapName</code> or <code>@CacheName</code> annotation.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="specify-the-owning-session-name-2"><a class="anchor" href="#specify-the-owning-session-name-2"></a>7.1.1.3. Specify the Owning Session Name</h5>
<div class="paragraph">
<p>In applications that use multiple <code>Sessions</code>, there may be a situation where more than one session has a map with
the same name. In those cases an observer method may need to restrict the events it receives to a specific session.
The events can be restricted to <code>maps</code> and/or <code>caches</code> in specific sessions using the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="listingblock">
<div class="title">Listening to events for the "orders" map in ALL sessions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onOrdersEventAllSessions(@MapName("orders")  <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the map named <code>orders</code> in <em>all</em> sessions.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listening to events for the "orders" map in the "Customer" session only</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onOrdersEventInCustomerSession(@MapName("orders")
                        @SessionName("Customer")             <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the map named <code>orders</code> owned by the <code>Session</code> named <code>Customer</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listening to events for ALL caches in the "Customer" session</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onEventInAllCachesInCustomerSession(@SessionName("Customer") <i class="conum" data-value="1"></i><b>(1)</b>
                                MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The above method receives events for the <em>all</em> caches owned by the <code>Session</code> named <code>Customer</code> as there is no <code>@MapName</code> or <code>@CacheName</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Therefore, in application with multiple sessions, events with the same name can be routed by session.</p>
</div>
<div class="listingblock">
<div class="title">Route events with the cache name by the name of the session</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onCustomerOrders(@SessionName("Customer")    <i class="conum" data-value="1"></i><b>(1)</b>
                                 @MapName("orders")
                                 MapEvent&lt;String, Order&gt; event) {
        // TODO: process the event
    }

    @CoherenceEventListener
    public void onCatalogOrders(@SessionName("Catalog")      <i class="conum" data-value="2"></i><b>(2)</b>
                                @MapName("orders")
                                MapEvent&lt;String, Order&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>onCustomerOrders</code> method will receive events for the <code>orders</code> map owned by the <code>Session</code> named <code>Customer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>onCatalogOrders</code> method will receive events for the <code>orders</code> map owned by the <code>Session</code> named <code>Catalog</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-events-mapevent-listeners-specific-events"><a class="anchor" href="#coherence-spring-events-mapevent-listeners-specific-events"></a>7.1.2. Receive Specific Event Types</h4>
<div class="paragraph">
<p>There are three types of event that a <code>MapEvent</code> observer method can receive:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Insert</code></p>
</li>
<li>
<p><code>Update</code></p>
</li>
<li>
<p><code>Delete</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, an observer method will receive all events for the map (or maps) it applies to. This can be controlled using
the following annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Inserted.html">@Inserted</a> - to receive <code>Insert</code> events.</p>
</li>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Updated.html">@Updated</a> - to receive <code>Update</code> events.</p>
</li>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Deleted.html">@Deleted</a> - to receive <code>Delete</code> events.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Zero or more of the above annotations can be used to annotate the <code>MapEvent</code> parameter of the observer method.</p>
</div>
<div class="listingblock">
<div class="title">Listen to "Insert" event for the "test" map only</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onInsertEvent(@MapName("test")
                        @Inserted                            <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only <code>Insert</code> events for the map <code>test</code> will be received.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listen to "Insert" and "Delete" events for the "test" map only</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onInsertAndDeleteEvent(@MapName("test")
                        @Inserted @Deleted                   <i class="conum" data-value="1"></i><b>(1)</b>
                        MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only <code>Insert</code> and <code>Delete</code> events for the map <code>test</code> will be received.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Listen to ALL map events for the "test" map</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    public void onMapEvent(@MapName("test") MapEvent&lt;String, String&gt; event) {
        // TODO: process the event
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>All events for the map <code>test</code> will be received.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-events-mapevent-listeners-filtering-events"><a class="anchor" href="#coherence-spring-events-mapevent-listeners-filtering-events"></a>7.1.3. Filtering Events</h4>
<div class="paragraph">
<p>The <code>MapEvents</code> received by an observer method can be further restricted by applying a filter. Filters are applied by
annotating the method with a <a href="#coherence-spring-filter-binding-annotations">filter binding</a> annotation, which is a link
to a factory that creates a specific instance of a <a href="https://coherence.community/23.03/api/java/com/tangosol/util/Filter.html">Filter</a>. Event
filters applied in this way are executed on the server, which can make receiving events more efficient for clients, as
the event will not be sent from the server at all.</p>
</div>
<div class="paragraph">
<p>Coherence Spring comes with some built in implementations, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/AlwaysFilter.html">@AlwaysFilter</a>,</p>
</li>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/WhereFilter.html">@WhereFilter</a>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is simple to implement custom filters as required by applications. Please refer to the
<a href="#coherence-spring-filter-binding-annotations">Filter Binding Annotation</a> section for more details.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s assume there is a map named <code>people</code> with keys of type <code>String</code> and values of type <code>People</code>, and an
observer method needs to receive events for all values where the <code>age</code> property is <code>18</code> or over. A custom filter binding
annotation could be written to create the required <code>Filter</code>. However, as the condition is very simple, the
built-in <code>@WhereFilter</code> filter binding annotation will be used in this example with a where-clause of <code>age &gt;= 18</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example of a Where Filter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @WhereFilter("age &gt;= 18")                    <i class="conum" data-value="1"></i><b>(1)</b>
    @CoherenceEventListener
    @MapName("people")
    public void onAdult(MapEvent&lt;String, Person&gt; people) {
        // TODO: process event...
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@WhereFilter</code> annotation is applied to the method.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>onAdult</code> method above will receive all events emitted from the <code>people</code> map, but only for entries where the value
of the <code>age</code> property of the entry value is <code>&gt;= 18</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-events-mapevent-listeners-transforming-events"><a class="anchor" href="#coherence-spring-events-mapevent-listeners-transforming-events"></a>7.1.4. Transforming Events</h4>
<div class="paragraph">
<p>In some use-cases the <code>MapEvent</code> observer method does not require the whole map or cache value to process, it might only
require one, or a few, properties of the value, or it might require some calculated value. This can be achieved by
using an event transformer to convert the values that will be received by the observer method. The transformation takes
place on the server before the event is emitted to the method. This can improve efficiency on a client in cases where
the cache value is large, but the client only requires a small part of that value because only the required values are
sent over the wire to the client.</p>
</div>
<div class="paragraph">
<p>In Coherence Spring, event values are transformed using a <a href="https://coherence.community/23.03/api/java/com/tangosol/util/ValueExtractor.html">ValueExtractor</a>.
A <code>ValueExtractor</code> is a simple interface that takes in one value and transforms it into another value. The <code>ValueExtractor</code>
is applied to the event value. As events contain both a new and old values, the extractor is applied to both as applicable.
For <code>Insert</code> events there is only a new value, for <code>Update</code> events there will be both, a new and an old value, and for
<code>Delete</code> events, there will only be an old value. The extractor is not applied to the event key.</p>
</div>
<div class="paragraph">
<p>The <code>ValueExtractor</code> to use for a <code>MapEvent</code> observer method is indicated by annotating the method with an
<a href="#coherence-spring-extractor-binding-annotations">extractor binding annotation</a>. An extractor binding is an annotation
that is itself annotated with the meta-annotation <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/ExtractorBinding.html">@ExtractorBinding</a>.
The extractor binding annotation is a link to a corresponding <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/ExtractorFactory.html">ExtractorFactory</a>
that will build an instance of a <code>ValueExtractor</code>.</p>
</div>
<div class="paragraph">
<p>For example, assuming that there is a <code>NamedMap</code> with the name <code>orders</code> that has keys of type <code>String</code> and values of type <code>Order</code>.
The <code>Order</code> class has a <code>customerId</code> property of type <code>String</code>. A <code>MapEvent</code> observer method is only interested in the
<code>customerId</code> for an order, so the built-in extractor binding annotation
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/PropertyExtractor.html">@PropertyExtractor</a> can be used
to just extract the <code>customerId</code> from the event:</p>
</div>
<div class="listingblock">
<div class="title">Example of a Property Extractor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    @PropertyExtractor("customerId")                         <i class="conum" data-value="1"></i><b>(1)</b>
    public void onOrder(@MapName("orders")                   <i class="conum" data-value="2"></i><b>(2)</b>
                        MapEvent&lt;String, String&gt; event) {    <i class="conum" data-value="3"></i><b>(3)</b>
        // TODO: process event...
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The method is annotated with <code>@PropertyExtractor</code> to indicate that a <code>ValueExtractor</code> that just extracts the <code>customerId</code>
property should be used to transform the event.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The map name to receive events from is set to <code>orders</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Note that the generic types of the <code>MapEvent</code> parameter are now <code>MapEvent&lt;String, String&gt;</code> instead of
<code>MapEvent&lt;String, Order&gt;</code> because the event values will have been transformed from an <code>Order</code> into just the <code>String</code>
<code>customerId</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to apply multiple filter binding annotations to a method. In this case the extractors are combined into a
Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/util/extractor/ChainedExtractor.html">ChainedExtractor</a>, which will return the
extracted values as a <code>java.util.List</code>.</p>
</div>
<div class="paragraph">
<p>Expanding on the example above, if the <code>Order</code> class also has an <code>orderId</code> property of type <code>Long</code>, and an observer
method, only interested in <code>Insert</code> events needs both the <code>customerId</code> and <code>orderId</code>, then the method can be annotated
with a two <code>@PropertyExtractor</code> annotations:</p>
</div>
<div class="listingblock">
<div class="title">Example of using multiple Property Extractors</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @CoherenceEventListener
    @PropertyExtractor("customerId")                              <i class="conum" data-value="1"></i><b>(1)</b>
    @PropertyExtractor("orderId")
    public void onOrderWithMultiplePropertyExtractors(
                        @Inserted                                 <i class="conum" data-value="2"></i><b>(2)</b>
                        @MapName("orders")
                        MapEvent&lt;String, List&lt;Object&gt;&gt; event) {   <i class="conum" data-value="3"></i><b>(3)</b>
        List list = event.getNewValue();
        String customerId = (String) list.get(0);                 <i class="conum" data-value="4"></i><b>(4)</b>
        Long orderId = (Long) list.get(1);
        // ...
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The method is annotated with two <code>@PropertyExtractor</code> annotations, one to extract <code>customerId</code> and one to extract <code>orderId</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method parameter is annotated with <code>@Inserted</code> so that the method only receives <code>Insert</code> events.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>MapEvent</code> parameter not has a key of type <code>String</code> and a value of type <code>List&lt;Object&gt;</code>, because the values from
the multiple extractors will be returned in a <code>List</code>. We cannot use a generic value narrower than <code>Object</code>
for the list because it will contain a <code>String</code> and a <code>Long</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The extracted values can be obtained from the list, they will be in the same order that the annotations were applied
to the method.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coherence-spring-events-event-interceptors"><a class="anchor" href="#coherence-spring-events-event-interceptors"></a>7.2. Coherence Event Interceptors</h3>
<div class="paragraph">
<p>Coherence produces many events in response to various server-side and client-side actions. For example, <em>Lifecycle events</em>
for Coherence itself, maps and cache, <em>Entry events</em> when data in maps and caches changes, <em>Partition events</em> for
partition lifecycle and distribution, <em>EntryProcessor events</em> when invoked on a map or cache, etc. In a stand-alone
Coherence application these events are subscribed to using a
<a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/EventInterceptor.html">EventInterceptor</a> implementation registered to listen
to specific event types.</p>
</div>
<div class="paragraph">
<p>The Coherence Spring API makes subscribing to these events simple, by using the same approach used for Spring Application
events, namely annotated event observer methods. A Coherence event observer method is a method annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>
that has a <code>void</code> return type, and a single parameter of the type of event to be received. The exact events received
can be further controlled by applying other annotations to the method or event parameter. The annotations applied will
vary depending on the type of the event.</p>
</div>
<div class="sect3">
<h4 id="event-types"><a class="anchor" href="#event-types"></a>7.2.1. Event Types</h4>
<div class="paragraph">
<p>The different types of event that can be observed are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/CoherenceLifecycleEvent.html">CoherenceLifecycleEvent</a> -
lifecycle events for  <a href="https://coherence.community/23.03/api/java/com/tangosol/net/Coherence.html">Coherence</a> instances</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/SessionLifecycleEvent.html">SessionLifecycleEvent</a> -
lifecycle events for <a href="https://coherence.community/23.03/api/java/com/tangosol/net/Session.html">Session</a> instances</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/application/LifecycleEvent.html">LifecycleEvent</a> -
lifecycle events for <a href="https://coherence.community/23.03/api/java/com/tangosol/net/ConfigurableCacheFactory.html">ConfigurableCacheFactory</a> instances</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/CacheLifecycleEvent.html">CacheLifecycleEvent</a> -
lifecycle events for <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedMap.html">NamedMap</a> and <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedCache.html">NamedCache</a> instances</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/EntryEvent.html">EntryEvent</a> - events emitted by the
mutation of entries in a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedMap.html">NamedMap</a>
or <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedCache.html">NamedCache</a></p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/EntryProcessorEvent.html">EntryProcessorEvent</a> - events emitted
by the invocation of an <a href="https://coherence.community/23.03/api/java/com/tangosol/util/InvocableMap.EntryProcessor.html">EntryProcessor</a> on entries in a
<a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedMap.html">NamedMap</a> or <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedCache.html">NamedCache</a></p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransactionEvent.html">TransactionEvent</a> - events pertaining to
all mutations performed within the context of a single request in a partition of a
<a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedMap.html">NamedMap</a> or <a href="https://coherence.community/23.03/api/java/com/tangosol/net/NamedCache.html">NamedCache</a>,
also referred to as "partition level transactions".</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html">TransferEvent</a> - captures information
concerning the transfer of a partition for a storage enabled member.</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/UnsolicitedCommitEvent.html">UnsolicitedCommitEvent</a> - captures
changes pertaining to all observed mutations performed against caches that were not directly caused (solicited) by the
partitioned service. These events may be due to changes made internally by the backing map, such as eviction, or referrers
of the backing map causing changes.</p>
</li>
<li>
<p>If using commercial versions of Coherence with Coherence Spring, there are also events associated to
the federation of data between different clusters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the events above only apply to storage enabled cluster members. For example, an <code>EntryEvent</code> will only be
emitted for mutations of an entry on the storage enabled cluster member that owns that entry. Lifecycle events on the
other hand, may be emitted on all members, such as <code>CacheLifecycle</code> event that may be emitted on any member when a cache
is created, truncated, or destroyed.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-lifecycle-events"><a class="anchor" href="#coherence-lifecycle-events"></a>7.2.2. Coherence Lifecycle Events</h4>
<div class="paragraph">
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/application/LifecycleEvent.html">LifecycleEvent</a> are emitted to indicate the lifecycle of a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/ConfigurableCacheFactory.html">ConfigurableCacheFactory</a> instance.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>LifecycleEvent</code> simply create a Spring bean with a listener method that is annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>LifecycleEvent</code>.</p>
</div>
<div class="paragraph">
<p><code>LifecycleEvent</code> are emitted by <code>ConfigurableCacheFactory</code> instances and will only be received in the same JVM, which could be a cluster member or a client.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive lifecycle events for all <code>ConfigurableCacheFactory</code> instances in the current application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(LifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-lifecycleevent-types"><a class="anchor" href="#receive-specific-lifecycleevent-types"></a>7.2.2.1. Receive Specific LifecycleEvent Types</h5>
<div class="paragraph">
<p>There are four different types of <code>LifecycleEvent</code>.
By adding the corresponding annotation to the method parameter the method will only receive the specified events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Activating</strong> - a <code>ConfigurableCacheFactory</code> instance is about to be activated, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Activating.html">@Activating</a> annotation</p>
</li>
<li>
<p><strong>Activated</strong> - a <code>ConfigurableCacheFactory</code> instance has been activated, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Activated.html">@Activated</a> annotation</p>
</li>
<li>
<p><strong>Disposing</strong> - a <code>ConfigurableCacheFactory</code> instance is about to be disposed, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Disposing.html">@Disposing</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the method below will only receive <code>Activated</code> and <code>Disposing</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Activated @Disposing LifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-coherencelifecycleevents-for-a-specific-coherence-instance"><a class="anchor" href="#receive-coherencelifecycleevents-for-a-specific-coherence-instance"></a>7.2.2.2. Receive CoherenceLifecycleEvents for a Specific Coherence Instance</h5>
<div class="paragraph">
<p>Each <code>Coherence</code> instance in an application has a unique name. The observer method can be annotated to only receive events associated with a specific <code>Coherence</code> instance by using the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation.</p>
</div>
<div class="paragraph">
<p>For example, the method below will only receive events for the <code>Coherence</code> instance named <code>customers</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name("customers") CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method in this example will receive events for the default <code>Coherence</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name(Coherence.DEFAULT_NAME) CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="session-lifecycle-events"><a class="anchor" href="#session-lifecycle-events"></a>7.2.3. Session Lifecycle Events</h4>
<div class="paragraph">
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/SessionLifecycleEvent.html">SessionLifecycleEvents</a> are emitted to indicate
the lifecycle event of a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/Session.html">Session</a> instance.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>SessionLifecycleEvents</code> simply create a Spring bean with a listener method annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>SessionLifecycleEvent</code>.</p>
</div>
<div class="paragraph">
<p><code>SessionLifecycleEvents</code> are emitted by <code>Session</code> instances and will only be received in the same JVM, which could be a cluster member or a client.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive lifecycle events for all <code>Session</code> instances in the current application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(SessionLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-sessionlifecycleevent-types"><a class="anchor" href="#receive-specific-sessionlifecycleevent-types"></a>7.2.3.1. Receive Specific SessionLifecycleEvent Types</h5>
<div class="paragraph">
<p>There are four different types of <code>SessionLifecycleEvent</code>.
By adding the corresponding annotation to the method parameter the method will only receive the specified events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Starting</strong> - a <code>Coherence</code> instance is about to start, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Starting.html">@Starting</a> annotation</p>
</li>
<li>
<p><strong>Started</strong> - a <code>Coherence</code> instance has started, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Started.html">@Started</a> annotation</p>
</li>
<li>
<p><strong>Stopping</strong> - a <code>Coherence</code> instance is about to stop, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Stopping.html">@Stopping</a> annotation</p>
</li>
<li>
<p><strong>Stopped</strong> - a <code>Coherence</code> instance has stopped, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Stopped.html">@Stopped</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the method below will only receive <code>Started</code> and <code>Stopped</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Started @Stopped SessionLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-sessionlifecycleevents-for-a-specific-session-instance"><a class="anchor" href="#receive-sessionlifecycleevents-for-a-specific-session-instance"></a>7.2.3.2. Receive SessionLifecycleEvents for a Specific Session Instance</h5>
<div class="paragraph">
<p>Each <code>Session</code> instance in an application has a name. The observer method can be annotated to only receive events
associated with a specific <code>Session</code> instance by using the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation.</p>
</div>
<div class="paragraph">
<p>For example, the method below will only receive events for the <code>Session</code> instance named <code>customers</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name("customers") SessionLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method in this example will receive events for the default <code>Coherence</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name(Coherence.DEFAULT_NAME) SessionLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configurablecachefactory-lifecycle-events"><a class="anchor" href="#configurablecachefactory-lifecycle-events"></a>7.2.4. ConfigurableCacheFactory Lifecycle Events</h4>
<div class="paragraph">
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/CoherenceLifecycleEvent.html">CoherenceLifecycleEvents</a> are emitted to
indicate the lifecycle of a <a href="https://coherence.community/23.03/api/java/com/tangosol/net/Coherence.html">Coherence</a> instance.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>CoherenceLifecycleEvent</code> simply create a Spring bean with a listener method annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>CoherenceLifecycleEvent</code>.</p>
</div>
<div class="paragraph">
<p><code>CoherenceLifecycleEvent</code> are emitted by <code>Coherence</code> instances and will only be received in the same JVM, which could be
a cluster member or a client.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive lifecycle events for all <code>Coherence</code> instances in the current application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-coherencelifecycleevent-types"><a class="anchor" href="#receive-specific-coherencelifecycleevent-types"></a>7.2.4.1. Receive Specific CoherenceLifecycleEvent Types</h5>
<div class="paragraph">
<p>There are four different types of <code>CoherenceLifecycleEvent</code>.
By adding the corresponding annotation to the method parameter the method will only receive the specified events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Starting</strong> - a <code>Coherence</code> instance is about to start, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Starting.html">@Starting</a> annotation</p>
</li>
<li>
<p><strong>Started</strong> - a <code>Coherence</code> instance has started, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Started.html">@Started</a> annotation</p>
</li>
<li>
<p><strong>Stopping</strong> - a <code>Coherence</code> instance is about to stop, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Stopping.html">@Stopping</a> annotation</p>
</li>
<li>
<p><strong>Stopped</strong> - a <code>Coherence</code> instance has stopped, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Stopped.html">@Stopped</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the method below will only receive <code>Started</code> and <code>Stopped</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Started @Stopped CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-coherencelifecycleevents-for-a-specific-coherence-instance-2"><a class="anchor" href="#receive-coherencelifecycleevents-for-a-specific-coherence-instance-2"></a>7.2.4.2. Receive CoherenceLifecycleEvents for a Specific Coherence Instance</h5>
<div class="paragraph">
<p>Each <code>Coherence</code> instance in an application has a unique name. The observer method can be annotated to only receive events associated with a specific <code>Coherence</code> instance by using the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Name.html">@Name</a> annotation.</p>
</div>
<div class="paragraph">
<p>For example, the method below will only receive events for the <code>Coherence</code> instance named <code>customers</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name("customers") CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method in this example will receive events for the default <code>Coherence</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Name(Coherence.DEFAULT_NAME) CoherenceLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-lifecycle-events"><a class="anchor" href="#cache-lifecycle-events"></a>7.2.5. Cache Lifecycle Events</h4>
<div class="paragraph">
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/CacheLifecycleEvent.html">CacheLifecycleEvent</a> are emitted to indicate the lifecycle of a cache instance.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>CacheLifecycleEvent</code> simply create a Spring bean with a listener method annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>CacheLifecycleEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive lifecycle events for all caches.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(CacheLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-cachelifecycleevent-types"><a class="anchor" href="#receive-specific-cachelifecycleevent-types"></a>7.2.5.1. Receive Specific CacheLifecycleEvent Types</h5>
<div class="paragraph">
<p>There are three types of `CacheLifecycleEvent:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Created</strong> - a cache instance has been created, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Created.html">@Created</a> annotation</p>
</li>
<li>
<p><strong>Truncated</strong> - a cache instance has been truncated (all data was removed), use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Truncated.html">@Truncated</a> annotation</p>
</li>
<li>
<p><strong>Destroyed</strong> - a cache has been destroyed (destroy is a cluster wide operation, so the cache is destroyed on all members of the cluster and clients) use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Destroyed.html">@Destroyed</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the method below will only receive <code>Created</code> and <code>Destroyed</code> events for all caches.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Created @Destroyed CacheLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-cachelifecycleevents-for-a-specific-namedmap-or-namedcache"><a class="anchor" href="#receive-cachelifecycleevents-for-a-specific-namedmap-or-namedcache"></a>7.2.5.2. Receive CacheLifecycleEvents for a Specific NamedMap or NamedCache</h5>
<div class="paragraph">
<p>To only receive events for a specific <code>NamedMap</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/MapName.html">@MapName</a> annotation.
To only receive events for a specific <code>NamedCache</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/CacheName.html">@CacheName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The <code>@MapName</code> and <code>@CacheName</code> annotations are actually interchangeable so use whichever reads better for your application code, i.e. if your code is dealing with <code>NamedMap</code> used <code>@MapName</code>. At the storage level, where the events are generated a <code>NamedMap</code> and <code>NamedCache</code> are the same.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the map named <code>orders</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@MapName("orders") CacheLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-cachelifecycleevents-from-a-specific-cache-service"><a class="anchor" href="#receive-cachelifecycleevents-from-a-specific-cache-service"></a>7.2.5.3. Receive CacheLifecycleEvents from a Specific Cache Service</h5>
<div class="paragraph">
<p>Caches are owned by a Cache Service, it is possible to restrict events received by a method to only those related to caches owned by a specific service by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the service named <code>StorageService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@ServiceName("StorageService") CacheLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-cachelifecycleevents-from-a-specific-session"><a class="anchor" href="#receive-cachelifecycleevents-from-a-specific-session"></a>7.2.5.4. Receive CacheLifecycleEvents from a Specific Session</h5>
<div class="paragraph">
<p>A typical use case is to obtain <code>NamedCache</code> and <code>NamedMap</code> instances from a <code>Session</code>. It is possible to restrict events received by a method to only those related to caches owned by a specific <code>Session</code> by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the <code>Session</code> named <code>BackEnd</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@SessionName("BackEnd") CacheLifecycleEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entry-events"><a class="anchor" href="#entry-events"></a>7.2.6. Entry Events</h4>
<div class="paragraph">
<p>An <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/EntryEvent.html">EntryEvent</a> is emitted when
a <a href="https://coherence.community/23.03/api/java/com/tangosol/util/InvocableMap.EntryProcessor.html">EntryProcessor</a> is invoked on a cache. These
events are only emitted on the storage enabled member that is the primary owner of the entry that the <code>EntryProcessor</code>
is invoked on.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>EntryProcessorEvent</code> simply create a Spring bean with a listener method annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>EntryEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive entry events for all caches.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(EntryEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-entryevent-types"><a class="anchor" href="#receive-specific-entryevent-types"></a>7.2.6.1. Receive Specific EntryEvent Types</h5>
<div class="paragraph">
<p>There are a number of different <code>EntryEvent</code> types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Inserting</strong> - an entry is being inserted into a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Inserting.html">@Inserting</a> annotation</p>
</li>
<li>
<p><strong>Inserted</strong> - an entry has been inserted into a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Inserted.html">@Inserted</a> annotation</p>
</li>
<li>
<p><strong>Updating</strong> - an entry is being updated in a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Updating.html">@Updating</a> annotation</p>
</li>
<li>
<p><strong>Updated</strong> - an entry has been updated in a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Updated.html">@Updated</a> annotation</p>
</li>
<li>
<p><strong>Removing</strong> - an entry is being deleted from a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Removing.html">@Removing</a> annotation</p>
</li>
<li>
<p><strong>Removed</strong> - an entry has been deleted from a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Removed.html">@Removed</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To restrict the <code>EntryEvent</code> types received by a method apply one or more of the annotations above to the method parameter.
For example, the method below will receive <code>Inserted</code> and <code>Removed</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Inserted @Removed EntryEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The event types fall into two categories, pre-events (those named <em>*ing</em>) and post-events, those named <em>*ed</em>). Pre-events
are emitted synchronously before the entry is mutated. Post-events are emitted asynchronously after the entry has been mutated.</p>
</div>
<div class="paragraph">
<p>As pre-events are synchronous the listener method should not take a long time to execute as it is blocking the cache
mutation and could obviously be a performance impact. It is also important that developers understand Coherence reentrancy
as the pre-events are executing on the Cache Service thread so cannot call into caches owned by the same service.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache"><a class="anchor" href="#receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache"></a>7.2.6.2. Receive EntryProcessorEvents for a Specific NamedMap or NamedCache</h5>
<div class="paragraph">
<p>To only receive events for a specific <code>NamedMap</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/MapName.html">@MapName</a> annotation.
To only receive events for a specific <code>NamedCache</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/CacheName.html">@CacheName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The <code>@MapName</code> and <code>@CacheName</code> annotations are actually interchangeable so use whichever reads better for your application code, i.e. if your code is dealing with <code>NamedMap</code> used <code>@MapName</code>. At the storage level, where the events are generated a <code>NamedMap</code> and <code>NamedCache</code> are the same.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the map named <code>orders</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@MapName("orders") EntryProcessorEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-from-a-specific-cache-service"><a class="anchor" href="#receive-entryprocessorevents-from-a-specific-cache-service"></a>7.2.6.3. Receive EntryProcessorEvents from a Specific Cache Service</h5>
<div class="paragraph">
<p>Caches are owned by a Cache Service, it is possible to restrict events received by a method to only those related to caches owned by a specific service by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the service named <code>StorageService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@ServiceName("StorageService") EntryProcessorEvents event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-from-a-specific-session"><a class="anchor" href="#receive-entryprocessorevents-from-a-specific-session"></a>7.2.6.4. Receive EntryProcessorEvents from a Specific Session</h5>
<div class="paragraph">
<p>A typical use case is to obtain <code>NamedCache</code> and <code>NamedMap</code> instances from a <code>Session</code>. It is possible to restrict events received by a method to only those related to caches owned by a specific <code>Session</code> by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the <code>Session</code> named <code>BackEnd</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@SessionName("BackEnd") EntryProcessorEvents event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entryprocessor-events"><a class="anchor" href="#entryprocessor-events"></a>7.2.7. EntryProcessor Events</h4>
<div class="paragraph">
<p>An <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/cache/EntryProcessorEvent.html">EntryProcessorEvent</a> is emitted when a mutation occurs on an entry in a cache. These events are only emitted on the storage enabled member that is the primary owner of the entry.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>EntryProcessorEvent</code> simply create a Spring bean with a listener method annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>EntryProcessorEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive entry events for all caches.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(EntryProcessorEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-entryprocessorevent-types"><a class="anchor" href="#receive-specific-entryprocessorevent-types"></a>7.2.7.1. Receive Specific EntryProcessorEvent Types</h5>
<div class="paragraph">
<p>There are a number of different <code>EntryProcessorEvent</code> types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Executing - an <code>EntryProcessor</code> is being invoked on a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Executing.html">@Executing</a> annotation</p>
</li>
<li>
<p>Executed - an <code>EntryProcessor</code> has been invoked on a cache, use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Executed.html">@Executed</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To restrict the <code>EntryProcessorEvent</code> types received by a method apply one or more of the annotations above to the method parameter. For example, the method below will receive <code>Executed</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Executed EntryProcessorEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The event types fall into two categories, pre-event ('Executing') and post-event (<code>Executed</code>). Pre-events are emitted synchronously before the <code>EntryProcessor</code> is invoked. Post-events are emitted asynchronously after the <code>EntryProcessor</code> has been invoked.</p>
</div>
<div class="paragraph">
<p>As pre-events are synchronous the listener method should not take a long time to execute as it is blocking the <code>EntryProcessor</code> invocation and could obviously be a performance impact. It is also important that developers understand Coherence reentrancy as the pre-events are executing on the Cache Service thread so cannot call into caches owned by the same service.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache-2"><a class="anchor" href="#receive-entryprocessorevents-for-a-specific-namedmap-or-namedcache-2"></a>7.2.7.2. Receive EntryProcessorEvents for a Specific NamedMap or NamedCache</h5>
<div class="paragraph">
<p>To only receive events for a specific <code>NamedMap</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/MapName.html">@MapName</a> annotation.
To only receive events for a specific <code>NamedCache</code> annotate the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/CacheName.html">@CacheName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The <code>@MapName</code> and <code>@CacheName</code> annotations are actually interchangeable so use whichever reads better for your application code, i.e. if your code is dealing with <code>NamedMap</code> used <code>@MapName</code>. At the storage level, where the events are generated a <code>NamedMap</code> and <code>NamedCache</code> are the same.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the map named <code>orders</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@MapName("orders") EntryProcessorEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-from-a-specific-cache-service-2"><a class="anchor" href="#receive-entryprocessorevents-from-a-specific-cache-service-2"></a>7.2.7.3. Receive EntryProcessorEvents from a Specific Cache Service</h5>
<div class="paragraph">
<p>Caches are owned by a Cache Service, it is possible to restrict events received by a method to only those related to caches owned by a specific service by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the service named <code>StorageService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@ServiceName("StorageService") EntryProcessorEvents event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-entryprocessorevents-from-a-specific-session-2"><a class="anchor" href="#receive-entryprocessorevents-from-a-specific-session-2"></a>7.2.7.4. Receive EntryProcessorEvents from a Specific Session</h5>
<div class="paragraph">
<p>A typical use case is to obtain <code>NamedCache</code> and <code>NamedMap</code> instances from a <code>Session</code>. It is possible to restrict events received by a method to only those related to caches owned by a specific <code>Session</code> by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/SessionName.html">@SessionName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the <code>Session</code> named <code>BackEnd</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@SessionName("BackEnd") EntryProcessorEvents event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="partition-level-transaction-events"><a class="anchor" href="#partition-level-transaction-events"></a>7.2.8. Partition Level Transaction Events</h4>
<div class="paragraph">
<p>A <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransactionEvent.html">TransactionEvent</a> is emitted in relation to all mutations in a single partition in response to executing a single request.
These are commonly referred to as partition level transactions.
For example, an <code>EntryProcessor</code> that mutates more than one entry (which could be in multiple caches) as part of a single invocation will cause a partition level transaction to occur encompassing all of those cache entries.</p>
</div>
<div class="paragraph">
<p>Transaction events are emitted by storage enabled cache services, they will only e received on the same member that the partition level transaction occurred.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>TransactionEvent</code> simply create a Spring bean with a listener method annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>TransactionEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive all transaction events emitted by storage enabled cache services in the same JVM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(TransactionEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-transactionevent-types"><a class="anchor" href="#receive-specific-transactionevent-types"></a>7.2.8.1. Receive Specific TransactionEvent Types</h5>
<div class="paragraph">
<p>There are a number of different <code>TransactionEvent</code> types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Committing</strong> - A COMMITTING event is raised prior to any updates to the underlying backing map.
This event will contain all modified entries which may span multiple backing maps. Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Inserting.html">@Committing</a> annotation</p>
</li>
<li>
<p><strong>Committed</strong> - A COMMITTED event is raised after any mutations have been committed to the underlying backing maps.
This event will contain all modified entries which may span multiple backing maps.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Inserted.html">@Committed</a> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To restrict the <code>TransactionEvent</code> types received by a method apply one or more of the annotations above to the method parameter. For example, the method below will receive <code>Committed</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Committed TransactionEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="receive-transactionevent-from-a-specific-cache-service"><a class="anchor" href="#receive-transactionevent-from-a-specific-cache-service"></a>7.2.8.2. Receive TransactionEvent from a Specific Cache Service</h5>
<div class="paragraph">
<p>Caches are owned by a Cache Service, it is possible to restrict events received by a method to only those related to caches owned by a specific service by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the service named <code>StorageService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@ServiceName("StorageService") TransactionEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="partition-transfer-events"><a class="anchor" href="#partition-transfer-events"></a>7.2.9. Partition Transfer Events</h4>
<div class="paragraph">
<p>A <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html">TransferEvent</a> captures information concerning the transfer of a partition for a storage enabled member. Transfer events are raised against the set of <a href="https://coherence.community/23.03/api/java/com/tangosol/util/BinaryEntry.html">BinaryEntry</a> instances that are being transferred.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TransferEvents are dispatched to interceptors while holding a lock on the partition being transferred, blocking any operations for the partition. Event observer methods should therefore execute as quickly as possible of hand-off execution to another thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To subscribe to <code>TransferEvent</code> simply create a Spring bean with a listener method annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>TransferEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive all transaction events emitted by storage enabled cache services in the same JVM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(TransferEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="receive-specific-transferevent-types"><a class="anchor" href="#receive-specific-transferevent-types"></a>7.2.9.1. Receive Specific TransferEvent Types</h5>
<div class="paragraph">
<p>There are a number of different <code>TransferEvent</code> types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Arrived</strong> - This <code>TransferEvent</code> is dispatched when a set of <code>BinaryEntry</code> instances have been transferred to the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a> or restored from backup.The reason for the event (primary transfer from another member or restore from backup) can be derived as follows:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TransferEvent event;
boolean restored = event.getRemoteMember() == event.getLocalMember();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Arrived.html">@Arrived</a> annotation to restrict the received events to arrived type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Assigned</strong> -  This <code>TransferEvent</code> is dispatched when a partition has been assigned to the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a>. This event will only be emitted by the ownership senior during the initial partition assignment.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Assigned.html">@Assigned</a> annotation to restrict received events.</p>
</li>
<li>
<p><strong>Departing</strong> - This <code>TransferEvent</code> is dispatched when a set of <code>BinaryEntry</code> are being transferred from the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a>. This event is followed by either a <code>Departed</code> or <code>Rollback</code> event to indicate the success or failure of the transfer.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Departing.html">@Departing</a> annotation to restrict received events.</p>
</li>
<li>
<p><strong>Departed</strong> - This <code>TransferEvent</code> is dispatched when a partition has been successfully transferred from the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a>. To derive the <code>BinaryEntry</code> instances associated with the transfer, consumers should subscribe to the <code>Departing</code> event that would precede this event.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Departed.html">@Departed</a> annotation to restrict received events.</p>
</li>
<li>
<p><strong>Lost</strong> - This <code>TransferEvent</code> is dispatched when a partition has been orphaned (data loss <em>may</em> have occurred), and the ownership is assumed by the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a>. This event is only be emitted by the ownership senior.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Lost.html">@Lost</a> annotation to restrict received events.</p>
</li>
<li>
<p><strong>Recovered</strong> - This <code>TransferEvent</code> is dispatched when a set of <code>BinaryEntry</code> instances have been recovered from a persistent storage by the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/TransferEvent.html#getLocalMember()">local member</a>.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Recovered.html">@Recovered</a> annotation to restrict received events.</p>
</li>
<li>
<p><strong>Rollback</strong> - This <code>TransferEvent</code> is dispatched when partition transfer has failed and was therefore rolled back. To derive the <code>BinaryEntry</code> instances associated with the failed transfer, consumers should subscribe to the <code>Departing</code> event that would precede this event.
Use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/Rollback.html">@Rollback</a> annotation to restrict received events.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To restrict the <code>TransferEvent</code> types received by a method apply one or more of the annotations above to the method parameter. For example, the method below will receive <code>Lost</code> events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@Lost TransferEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple type annotations may be used to receive multiple types of <code>TransferEvent</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="receive-transferevent-from-a-specific-cache-service"><a class="anchor" href="#receive-transferevent-from-a-specific-cache-service"></a>7.2.9.2. Receive TransferEvent from a Specific Cache Service</h5>
<div class="paragraph">
<p>Caches are owned by a Cache Service, it is possible to restrict events received by a method to only those related to caches owned by a specific service by annotating the method parameter with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/event/ServiceName.html">@ServiceName</a> annotation.</p>
</div>
<div class="paragraph">
<p>The method below will only receive events for the caches owned by the service named <code>StorageService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(@ServiceName("StorageService") TransferEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unsolicited-commit-events"><a class="anchor" href="#unsolicited-commit-events"></a>7.2.10. Unsolicited Commit Events</h4>
<div class="paragraph">
<p>An <a href="https://coherence.community/23.03/api/java/com/tangosol/net/events/partition/UnsolicitedCommitEvent.html">UnsolicitedCommitEvent</a> captures changes pertaining to all observed mutations performed against caches that were not directly caused (solicited) by the partitioned service. These events may be due to changes made internally by the backing map, such as eviction, or referrers of the backing map causing changes.</p>
</div>
<div class="paragraph">
<p>Unsolicited commit events are emitted by storage enabled cache services, they will only e received on the same member.</p>
</div>
<div class="paragraph">
<p>To subscribe to <code>UnsolicitedCommitEvent</code> simply create a Spring bean with a listener method annotated with <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/event/CoherenceEventListener.html">@CoherenceEventListener</a>.
The method should have a single parameter of type <code>UnsolicitedCommitEvent</code>.</p>
</div>
<div class="paragraph">
<p>For example, the <code>onEvent</code> method below will receive all Unsolicited commit events emitted by storage enabled cache services in the same JVM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceEventListener
public void onEvent(UnsolicitedCommitEvent event) {
    // TODO: process the event
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-filter-binding-annotations"><a class="anchor" href="#coherence-spring-filter-binding-annotations"></a>8. Filter Binding Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Filter binding annotations are normal annotations that are themselves annotated with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/FilterBinding.html">@FilterBinding</a> meta-annotation.
A filter binding annotation represents a Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/util/Filter.html">Filter</a> and is used
to specify a <code>Filter</code> in certain injection points, for example a View (CQC), <code>NamedTopic</code> <code>Subscriber</code> beans,
event listeners, etc.</p>
</div>
<div class="paragraph">
<p>There are three parts to using a filter binding:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The filter binding annotation</p>
</li>
<li>
<p>An implementation of a <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/FilterFactory.html">FilterFactory</a> that
is annotated with the filter binding annotation. This is a factory that produces the required <code>Filter</code>.</p>
</li>
<li>
<p>Injection points annotated with the filter binding annotation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We will put all three parts together in an example. Let&#8217;s use a Coherence <code>NamedMap</code> named <code>plants</code> that contains plants
represented by instances of the <code>Plant</code> class as map values. Among the various properties on the <code>Plant</code> class there is
a property called <code>plantType</code> and a property called <code>height</code>. In this example, we want to inject a view that only shows
large palm trees (any palm tree larger than 20 meters). We would need a <code>Filter</code> that has a condition like the following:
<code>plantType == PlantType.PALM &amp;&amp; height &gt;= 20</code>.</p>
</div>
<div class="sect2">
<h3 id="create-the-filter-binding-annotation"><a class="anchor" href="#create-the-filter-binding-annotation"></a>8.1. Create the filter binding annotation</h3>
<div class="paragraph">
<p>First create a simple annotation, it could be called something like <code>PlantNameExtractor</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import com.oracle.coherence.spring.annotation.FilterBinding;

@FilterBinding                                   <i class="conum" data-value="1"></i><b>(1)</b>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface LargePalmTrees {               <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The annotation class is annotated with <code>@FilterBinding</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The annotation name is <code>PlantNameExtractor</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this case the annotation does not need any other attributes.</p>
</div>
</div>
<div class="sect2">
<h3 id="create-the-filterfactory"><a class="anchor" href="#create-the-filterfactory"></a>8.2. Create the <code>FilterFactory</code></h3>
<div class="paragraph">
<p>Now create the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/FilterFactory.html">FilterFactory</a> implementation
that will produce instances of the required <code>Filter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.FilterFactory;
import com.tangosol.util.Extractors;
import com.tangosol.util.Filter;
import com.tangosol.util.Filters;
import org.springframework.stereotype.Component;

@LargePalmTrees                                              <i class="conum" data-value="1"></i><b>(1)</b>
@Component                                                   <i class="conum" data-value="2"></i><b>(2)</b>
public class LargePalmTreesFilterFactory&lt;Plant&gt;
        implements FilterFactory&lt;LargePalmTrees, Plant&gt; {
    @Override
    public Filter&lt;Plant&gt; create(LargePalmTrees annotation) { <i class="conum" data-value="3"></i><b>(3)</b>
        Filter&lt;Plant&gt; palm = Filters.equal("plantType", PlantType.PALM);
        Filter&lt;Plant&gt; height = Filters.greaterEqual(
                Extractors.extract("height"), 20);
        return Filters.all(palm, height);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The class is annotated with the <code>PlantNameExtractor</code> filter binding annotation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The class must be a Spring bean, let&#8217;s annotate it with <code>@Component</code> so that component scanning will pick this class
up as a Spring bean</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>create</code> method uses the Coherence <code>filters</code> API to create the required <code>filter</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parameter to the <code>create</code> method is the annotation used on the injection point.
In this case the annotation has no values, but if it did we could access those values to customize how the filter is created.</p>
</div>
<div class="paragraph">
<p>For example, we can make the filter more general purpose by calling the annotation <code>@PalmTrees</code> and by
adding a value parameter representing the height like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FilterBinding
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface PalmTrees {
    String value();
}
@FilterBinding
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface PalmTrees {
    int value() default 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then need to modify our filter factory to use the height value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.FilterFactory;
import com.tangosol.util.Extractors;
import com.tangosol.util.Filter;
import com.tangosol.util.Filters;
import org.springframework.stereotype.Component;

@PalmTrees                                                                <i class="conum" data-value="1"></i><b>(1)</b>
@Component                                                                <i class="conum" data-value="2"></i><b>(2)</b>
public class PalmTreesFilterFactory&lt;Plant&gt;
        implements FilterFactory&lt;PalmTrees, Plant&gt; {
    @Override
    public Filter&lt;Plant&gt; create(PalmTrees annotation) {                   <i class="conum" data-value="3"></i><b>(3)</b>
        Filter&lt;Plant&gt; palm = Filters.equal("plantType", PlantType.PALM);
        Filter&lt;Plant&gt; height = Filters.greaterEqual(
                Extractors.extract("height"), annotation.value());  <i class="conum" data-value="4"></i><b>(4)</b>
        return Filters.all(palm, height);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The class is annotated with the more flexible <code>PalmTrees</code> filter binding annotation accepting a height parameter</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The class must be a Spring bean, let&#8217;s annotate it with <code>@Component</code> so that component scanning will pick this class
up as a Spring bean</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>create</code> method uses the Coherence <code>filters</code> API to create the required <code>filter</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Instead of hard-coding the height, we use the value from the <code>@PalmTrees</code> annotation</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="annotate-the-injection-point"><a class="anchor" href="#annotate-the-injection-point"></a>8.3. Annotate the Injection Point</h3>
<div class="paragraph">
<p>Now the application code where the view is to be injected can use the custom filter binding annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @View                                                    <i class="conum" data-value="1"></i><b>(1)</b>
    @PalmTrees(1)                                            <i class="conum" data-value="2"></i><b>(2)</b>
    @CoherenceCache("plants")                                <i class="conum" data-value="3"></i><b>(3)</b>
    private NamedMap&lt;Long, Plant&gt; palmTrees;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@View</code> annotation indicates that this is a view rather than a plain <code>NamedMap</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@PalmTrees</code> annotation links to the custom filter factory which is used to create the filter for the view. The
annotation value of <code>1</code> indicates that we are interested in all palm trees of at least 1 meter in height.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Due to Spring limitations regarding the injection of Maps, we use the <code>@CoherenceMap</code> annotation to inject the <code>NamedMap</code>,
which also has takes an optional value to specify the name of the cache.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-extractor-binding-annotations"><a class="anchor" href="#coherence-spring-extractor-binding-annotations"></a>9. Extractor Binding Annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ValueExtractor binding annotations are normal annotations that are themselves annotated with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/ExtractorBinding.html">@ExtractorBinding</a> meta-annotation.
An extractor binding annotation represents a Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/util/ValueExtractor.html">ValueExtractor</a>
and is used to specify a <code>ValueExtractor</code> in certain injection points, for example a View (CQC), <code>NamedTopic</code> <code>Subscriber</code>
beans, <code>MapEvent</code> listeners, etc.</p>
</div>
<div class="paragraph">
<p>There are three parts to using an extractor binding:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The extractor binding annotation</p>
</li>
<li>
<p>An implementation of a <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/ExtractorFactory.html">ExtractorFactory</a> that is annotated with the extractor binding annotation. This is a factory that produces the required <code>ValueExtractor</code>.</p>
</li>
<li>
<p>Injection points annotated with the extractor binding annotation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As an example, let&#8217;s continue with our previous example, where we have a Coherence <code>NamedMap</code> named <code>plants</code> that contains
<code>Plant</code> instances as values. In this example we are interested in inject a map of plant names instead of the actual
plant instances. Each plant has a <code>name</code> property that we will use for that purpose. We will need a <code>ValueExtractor</code> that
extracts the <code>name</code> property and the resulting map of plant names can be injected into our Spring beans.</p>
</div>
<div class="sect2">
<h3 id="create-the-extractor-binding-annotation"><a class="anchor" href="#create-the-extractor-binding-annotation"></a>9.1. Create the extractor binding annotation</h3>
<div class="paragraph">
<p>First create a simple annotation called <code>PlantName</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtractorBinding                                <i class="conum" data-value="1"></i><b>(1)</b>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface PersonAge {                    <i class="conum" data-value="2"></i><b>(2)</b>
}

import com.oracle.coherence.spring.annotation.ExtractorBinding;
import com.oracle.coherence.spring.annotation.FilterBinding;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@ExtractorBinding                                <i class="conum" data-value="1"></i><b>(1)</b>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface PlantNameExtractor {           <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The annotation class is annotated with <code>@ExtractorBinding</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The annotation name is <code>PlantNameExtractor</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this case the annotation does not need any other attributes.</p>
</div>
</div>
<div class="sect2">
<h3 id="create-the-extractorfactory"><a class="anchor" href="#create-the-extractorfactory"></a>9.2. Create the <code>ExtractorFactory</code></h3>
<div class="paragraph">
<p>Now create the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/ExtractorFactory.html">ExtractorFactory</a>
implementation that will produce instances of the required <code>ValueExtractor</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.ExtractorFactory;
import com.tangosol.util.Extractors;
import com.tangosol.util.ValueExtractor;
import org.springframework.stereotype.Component;

@PlantNameExtractor                                          <i class="conum" data-value="1"></i><b>(1)</b>
@Component                                                   <i class="conum" data-value="2"></i><b>(2)</b>
public class PlantNameExtractorFactory&lt;Plant&gt;
        implements ExtractorFactory&lt;PlantNameExtractor, Plant, String&gt; {
    @Override
    public ValueExtractor&lt;Plant, String&gt; create(PlantNameExtractor annotation) {  <i class="conum" data-value="3"></i><b>(3)</b>
        return Extractors.extract("name");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The class is annotated with the <code>PlantNameExtractor</code> extractor binding annotation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The class must be a Spring bean, let&#8217;s annotate it with <code>@Component</code> so that component scanning will pick this class
up as a Spring bean</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>create</code> method uses the Coherence <code>Extractors</code> API to create the required extractor, in this case a trivial property extractor.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parameter to the <code>create</code> method is the annotation used on the injection point.
In this case the annotation has no values, but if it did we could access those values to customize how the <code>ValueExtractor</code> is created.</p>
</div>
</div>
<div class="sect2">
<h3 id="annotate-the-injection-point-2"><a class="anchor" href="#annotate-the-injection-point-2"></a>9.3. Annotate the Injection Point</h3>
<div class="paragraph">
<p>Now the application code where the view is to be injected can use the custom extractor binding annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@View                                            <i class="conum" data-value="1"></i><b>(1)</b>
@PersonAge                                       <i class="conum" data-value="2"></i><b>(2)</b>
@Name("people")                                  <i class="conum" data-value="3"></i><b>(3)</b>
private NamedMap&lt;String, Integer&gt; ages;          <i class="conum" data-value="4"></i><b>(4)</b>
    @View                                        <i class="conum" data-value="1"></i><b>(1)</b>
    @PlantNameExtractor                          <i class="conum" data-value="2"></i><b>(2)</b>
    @CoherenceMap("plants")                      <i class="conum" data-value="3"></i><b>(3)</b>
    private NamedMap&lt;Long, String&gt; plants;       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@View</code> annotation indicates that this is a view rather than a plain <code>NamedMap</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@PlantNameExtractor</code> annotation links to the custom extractor factory used to create the <code>ValueExtractor</code> for the view</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Due to Spring limitations regarding the injection of Maps, we use the <code>@CoherenceMap</code> annotation to inject the <code>NamedMap</code>,
which also has takes an optional value to specify the underlying cache/map name to use for the view.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Note that the <code>NamedMap</code> generics are now <code>Long</code> and <code>String</code> instead of <code>Long</code> and <code>Plant</code> as the <code>Plant</code> values
from the underlying cache are transformed into <code>String</code> values by extracting just the name property.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-messaging-with-coherence-topics"><a class="anchor" href="#coherence-spring-messaging-with-coherence-topics"></a>10. Messaging with Coherence Topics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Coherence integration provides support for message driven applications by virtue of Coherence topics.</p>
</div>
<div class="paragraph">
<p>A Coherence <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/NamedTopic.html">NamedTopic</a> is analogous to a queue or pub/sub topic, depending on the configuration and application code. Messages published to the topic are stored in Coherence caches, so topics are scalable and performant.</p>
</div>
<div class="paragraph">
<p>A typical stand-alone Coherence application would create a <code>NamedTopic</code> along with <code>Publisher</code> or <code>Subscriber</code> instances to publish to or subscribe to topics. Injection of topics into Spring applications is already covered in <a href="#coherence-spring-dependency-injection-namedtopic">Injecting NamedTopics</a>. With Spring messaging this becomes much simpler.</p>
</div>
<div class="paragraph">
<p>With Spring Coherence Messaging publishers and subscribers beans are created by writing suitably annotated interfaces.</p>
</div>
<div class="sect2">
<h3 id="define-publishers-coherencepublisher"><a class="anchor" href="#define-publishers-coherencepublisher"></a>10.1. Define Publishers - @CoherencePublisher</h3>
<div class="paragraph">
<p>To create a topic Publisher that sends messages, you can simply define an interface that is annotated with
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherencePublisher.html">@CoherencePublisher</a>. Also, your
configuration class has to be annotated with the
<a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherencePublisherScan.html">@CoherencePublisherScan</a>
annotation. This is needed to specify the base package from which we recursively scan for <code>@CoherencePublisher</code> annotated
interfaces.</p>
</div>
<div class="listingblock">
<div class="title">Config.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@CoherencePublisherScan("com.example.app.services")
public class Config {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example the following is a trivial <code>@CoherencePublisher</code> interface:</p>
</div>
<div class="listingblock">
<div class="title">ProductClient.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.CoherencePublisher;
import com.oracle.coherence.spring.annotation.Topic;

@CoherencePublisher                              <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductClient {

    @Topic("my-products")                        <i class="conum" data-value="2"></i><b>(2)</b>
    void sendProduct(String message);            <i class="conum" data-value="3"></i><b>(3)</b>

    void sendProduct(@Topic String topic, String message); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@CoherencePublisher</code> annotation is used to designate this interface as a message publisher.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Topic.html">@Topic</a> annotation indicates which topics the message should be published to</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method defines a single parameter, which is the message value. In this case the values being published are String instances but they could be any type that can be serialized by Coherence.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It is also possible for the topic to be dynamic by making it a method argument annotated with <code>@Topic</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At run time Spring will produce an implementation of the above interface. You can retrieve an instance of <code>ProductClient</code> either by looking up the bean from the <code>ApplicationContext</code> or by injecting the bean with <code>@Inject</code>:</p>
</div>
<div class="listingblock">
<div class="title">Using ProductClient</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ProductClient client = applicationContext.getBean(ProductClient.class);
client.sendProduct("Blue Trainers");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactive-and-non-blocking-method-definitions"><a class="anchor" href="#reactive-and-non-blocking-method-definitions"></a>10.2. Reactive and Non-Blocking Method Definitions</h3>
<div class="paragraph">
<p>The <code>@CoherencePublisher</code> annotation supports the definition of reactive return types (such as Reactor <code>Flux</code>) as well as Futures.</p>
</div>
<div class="paragraph">
<p>The following sections cover possible method signatures and behaviour:</p>
</div>
<div class="sect3">
<h4 id="mono-value-and-return-type"><a class="anchor" href="#mono-value-and-return-type"></a>10.2.1. Mono Value and Return Type</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;Publisher.Status&gt; sendBook(Mono&lt;Book&gt; book);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation will return a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> that when subscribed to will subscribe to the passed <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> and send a message emitting the resulting <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Publisher.Status.html">Publisher.Status</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactor-flux-value-and-return-type"><a class="anchor" href="#reactor-flux-value-and-return-type"></a>10.2.2. Reactor Flux Value and Return Type</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Publisher.Status&gt; sendBooks(Flux&lt;Book&gt; book);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation will return a Reactor <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> that when subscribed to will subscribe to the passed <code>Flux</code> and for each emitted item will send a message emitting the resulting <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Publisher.Status.html">Publisher.Status</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="future-return-type"><a class="anchor" href="#future-return-type"></a>10.2.3. Future Return Type</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Future&lt;Publisher.Status&gt; sendBooks(Mono&lt;Book&gt; book);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation will return a Future with publisher&#8217;s status.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="define-subscribers-coherencetopiclistener"><a class="anchor" href="#define-subscribers-coherencetopiclistener"></a>10.3. Define Subscribers - @CoherenceTopicListener</h3>
<div class="paragraph">
<p>To listen to Coherence topic messages you can use the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherenceTopicListener.html">@CoherenceTopicListener</a> annotation to define a message listener.</p>
</div>
<div class="paragraph">
<p>The following example will listen for messages published by the <code>ProductClient</code> in the previous section:</p>
</div>
<div class="listingblock">
<div class="title">ProductListener.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.annotation.CoherenceTopicListener;
import com.oracle.coherence.spring.annotation.Topic;

@CoherenceTopicListener                          <i class="conum" data-value="1"></i><b>(1)</b>
public class ProductListener {

    @Topic("my-products")                        <i class="conum" data-value="2"></i><b>(2)</b>
    public void receive(String product) {        <i class="conum" data-value="3"></i><b>(3)</b>
        System.out.println("Got Product - " + product);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherenceTopicListener.html">@CoherenceTopicListener</a> annotation to indicate that this bean is a Coherence topic listener.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/Topic.html">@Topic</a> annotation is again used to indicate which topic to subscribe to.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receive method defines single arguments that will receive the message value, in this case the message is of type <code>String</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="method-parameter-bindings"><a class="anchor" href="#method-parameter-bindings"></a>10.4. Method Parameter Bindings</h3>
<div class="paragraph">
<p>When using a Coherence topic <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Subscriber.html">Subscriber</a> directly in application code, the <code>receive</code> method returns an <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Subscriber.Element.html">Element</a>, which contains the message value and metadata. The annotated subscriber method can take various parameter types that will bind to the element itself or to the message.</p>
</div>
<div class="paragraph">
<p>For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceTopicListener
@Topic("my-products")
public void receive(Element&lt;Product&gt; product) {
    // ... process message ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method above will be passed the <a href="https://coherence.community/23.03/api/java/com/tangosol/net/topic/Subscriber.Element.html">Element</a> received from the topic. By receiving the element, the method has access to the message value and all the metadata stored with the message.</p>
</div>
</div>
<div class="sect2">
<h3 id="committing-messages"><a class="anchor" href="#committing-messages"></a>10.5. Committing Messages</h3>
<div class="paragraph">
<p>An important part of Coherence topic subscribers is committing messages to notify the server that they have been processed and guaranteeing at least once delivery. When using Micronaut Coherence messaging every message will be committed after the handler method has successfully processed the message. This behaviour can be controlled by adding a commit strategy to the <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherenceTopicListener.html">@CoherenceTopicListener</a> annotation.</p>
</div>
<div class="sect3">
<h4 id="default-commit-behaviour"><a class="anchor" href="#default-commit-behaviour"></a>10.5.1. Default Commit Behaviour</h4>
<div class="paragraph">
<p>If no <code>commitStrategy</code> field has been provided to the <code>@CoherenceTopicListener</code> annotation the default behaviour is to synchronously call <code>Element.commit()</code> for every message received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceTopicListener
@Topic("my-products")
public void receive(Element&lt;Product&gt; product) {
    // ... process message ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No <code>commitStrategy</code> field has been supplied to the <code>@CoherenceTopicListener</code> annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="setting-commit-strategy"><a class="anchor" href="#setting-commit-strategy"></a>10.5.2. Setting Commit Strategy</h4>
<div class="paragraph">
<p>The <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherenceTopicListener.html">@CoherenceTopicListener</a> <code>commitStrategy</code> field is an enumeration of type <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CommitStrategy.html">CommitStrategy</a> with three values, <code>SYNC</code>, <code>ASYNC</code> and <code>MANUAL</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CommitStrategy.SYNC - This strategy is the default, and will synchronously commit every message upon successful completion of the handler method, by calling <code>Element.commit()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceTopicListener(commitStrategy = CommitStrategy.SYNC)
@Topic("my-products")
public void receive(Product product) {
    // ... process message ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>CommitStrategy.ASYNC - This strategy will asynchronously commit every message upon successful completion of the handler method, by calling <code>Element.commitAsync()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceTopicListener(commitStrategy = CommitStrategy.ASYNC)
@Topic("my-products")
public void receive(Product product) {
    // ... process message ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>CommitStrategy.MANUAL - This strategy will not automatically commit messages, all handling of commits must be done as part of the handler method or by some external process.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CoherenceTopicListener(commitStrategy = CommitStrategy.MANUAL)
@Topic("my-products")
public void receive(Element&lt;Product&gt; product) {
    // ... process message ...

    // manually commit the element
    element.commit();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above a <code>MANUAL</code> commit strategy has used. The element will be committed by the application code at the end of the handler method. To be able to manually commit a message the method must take the <code>Element</code> as a parameter so that application code can access the commit methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="forwarding-messages-with-sendto"><a class="anchor" href="#forwarding-messages-with-sendto"></a>10.5.3. Forwarding Messages with @SendTo</h4>
<div class="paragraph">
<p>On any <a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/annotation/CoherenceTopicListener.html">@CoherenceTopicListener</a> method that returns a value, you can use the @SendTo annotation to forward the return value to the topic or topics specified by the @SendTo annotation.</p>
</div>
<div class="paragraph">
<p>The key of the original ConsumerRecord will be used as the key when forwarding the message.</p>
</div>
<div class="listingblock">
<div class="title">ProductListener.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.*;
import org.springframework.messaging.handler.annotation.SendTo;

@CoherenceTopicListener
public class ProductListener {

    @Topic("awesome-products")                   <i class="conum" data-value="1"></i><b>(1)</b>
    @SendTo("product-quantities")                <i class="conum" data-value="2"></i><b>(2)</b>
    public int receive(Product product) {
        System.out.println("Got Product - " + product.getName() + " by " + product.getBrand());
        return product.getQuantity();            <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The topic subscribed to is <code>awesome-products</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The topic to send the result to is <code>product-quantities</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The return value is used to indicate the value to forward</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also do the same using Reactive programming:</p>
</div>
<div class="listingblock">
<div class="title">ProductListener.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.*;
import org.springframework.messaging.handler.annotation.SendTo;
import reactor.core.publisher.Mono;

@CoherenceTopicListener
public class ProductListener {

    @Topic("awesome-products")                   <i class="conum" data-value="1"></i><b>(1)</b>
    @SendTo("product-quantities")                <i class="conum" data-value="2"></i><b>(2)</b>
    public Mono&lt;Integer&gt; receiveProduct(Mono&lt;Product&gt; productSingle) {
        return productSingle.map(product -&gt; {
            System.out.println("Got Product - " + product.getName() + " by " + product.getBrand());
            return product.getQuantity();        <i class="conum" data-value="3"></i><b>(3)</b>
        });
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The topic subscribed to is <code>awesome-products</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The topic to send the result to is <code>product-quantities</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The return is mapped from the single to the value of the quantity</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coherence-spring-cachestore"><a class="anchor" href="#coherence-spring-cachestore"></a>11. Cache Store</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coherence Spring provides dedicated support for database-backed caches using JPA. Spring Data&#8217;s
<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.repositories">JPA Repositories</a> make basic CRUD database access very simple. An application
developer can just provide an interface that extends <code>JpaRepository</code> with the required generic parameters and
Spring will do the rest.</p>
</div>
<div class="paragraph">
<p>Coherence caches that are backed by a database have two options for how the database integration is provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/cache/CacheLoader.html">CacheLoader</a> - an application developer writes an implementation of a <code>CacheLoader</code> to read data from a database for
a given key (or keys), convert it to entities that are then loaded into a cache for the given keys.</p>
</li>
<li>
<p><a href="https://coherence.community/23.03/api/java/com/tangosol/net/cache/CacheStore.html">CacheStore</a> - whilst a <code>CacheLoader</code> only loads from a database into a cache, a <code>CacheStore</code> (which extends
<code>CacheLoader</code>) also stores cached entities back to the database, or for entries deleted from the cache, erases the
corresponding values from the database. The parallels between a <code>CacheLoader</code> or <code>CacheStore</code> and a <code>JpaRepository</code>
should be pretty obvious.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Coherence Spring core module provides two interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/cachestore/JpaRepositoryCacheLoader.html">JpaRepositoryCacheLoader</a>, which extends both <code>JpaRepository</code> and <code>CacheLoader</code></p>
</li>
<li>
<p><a href="https://spring.coherence.community/4.0.0-SNAPSHOT/refdocs/api/com/oracle/coherence/spring/cachestore/JpaRepositoryCacheStore.html">JpaRepositoryCacheStore</a>, which extends both <code>JpaRepository</code> and <code>CacheStore</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To create a JPA repository cache loader or cache store, all a developer needs to do is extend the relevant interface
<code>JpaRepositoryCacheLoader</code> or <code>JpaRepositoryCacheStore</code> with the correct generic parameters. We will illustrate the use
of Cache Stores using the following example.</p>
</div>
<div class="sect2">
<h3 id="coherence-spring-cachestore-demo"><a class="anchor" href="#coherence-spring-cachestore-demo"></a>11.1. JPA Repository CacheStore Demo</h3>
<div class="paragraph">
<p>In this demo we are show-casing how to use Spring Data JPA repository beans as Coherence CacheStores in
applications using the <a href="https://github.com/coherence-community/coherence-spring">Coherence Spring project</a>.</p>
</div>
<div class="paragraph">
<p>The demo is split into multiple Maven modules in order to show-case <code>2</code> use-cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Embedded Coherence</p>
</li>
<li>
<p>Connect to a remote Coherence instance cache using
<a href="https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.2206/develop-remote-clients/introduction-coherenceextend.html">Coherence*Extend</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Maven Project is structured into the following modules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>coherence-cachestore-demo-app</strong> Main entry point for the demo using an embedded Coherence instance</p>
</li>
<li>
<p><strong>coherence-cachestore-demo-server</strong> Remote Coherence server we will connect to using Coherence*Extend</p>
</li>
<li>
<p><strong>coherence-cachestore-demo-core</strong> Contains common code shared between the local app and the remote Coherence server version</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-model"><a class="anchor" href="#coherence-spring-cachestore-demo-model"></a>11.1.1. Data Model</h4>
<div class="paragraph">
<p>At its core (and in the <code>coherence-cachestore-demo-core</code> module), the application has a simple class called <code>Person</code> that
is annotated with basic JPA annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
@Table(name = "PEOPLE")
public class Person implements Serializable {

    /**
     * The unique identifier for this person.
     */
    @Id
    private Long id;

    /**
     * The age of this person.
     */
    private int age;

    /**
     * The person's first name.
     */
    private String firstname;

    /**
     * The person's last name.
     */
    private String lastname;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The identifier of a <code>Person</code> is defined as <code>Long</code>, so in our Coherence-based application we would put these <code>Person</code>
instances into a Coherence <code>NamedMap&lt;Long, Person&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-jpa-repository"><a class="anchor" href="#coherence-spring-cachestore-demo-jpa-repository"></a>11.1.2. Writing a JPA Repository CacheStore</h4>
<div class="paragraph">
<p>To write a JPA repository <code>CacheStore</code> that can be used by our people cache we need to create a simple Spring Data
repository interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.oracle.coherence.spring.cachestore.JpaRepositoryCacheStore;
import org.springframework.stereotype.Repository;

@Repository
public interface PersonRepository extends JpaRepositoryCacheStore&lt;Person, Long&gt; {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is all the code required to write a <code>CacheStore</code> that can be plugged into Coherence. Spring Data will take care of
actually generating the implementation of the interface, and supplying that implementation as a bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-embedded"><a class="anchor" href="#coherence-spring-cachestore-demo-embedded"></a>11.1.3. Embedded Coherence</h4>
<div class="paragraph">
<p>In the embedded Coherence CacheStore demo we use a co-located Coherence instance that will start
as part of the application itself.</p>
</div>
<div class="paragraph">
<p>To use a <code>CacheStore</code> in Coherence, it needs to be configured in the Coherence cache configuration file, which in the
embedded use-case is <code>coherence-cache-config.xml</code>. In order to use the repository bean as a <code>CacheStore</code>, we will make
use of the Coherence Spring feature that allows injection of Spring beans into the cache configuration file.</p>
</div>
<div class="paragraph">
<p>To use Spring bean injection in the configuration file we need to declare a custom namespace in the root XML element that
references the Coherence Spring <code>NamespaceHandler</code>.</p>
</div>
<div class="listingblock">
<div class="title">coherence-cache-config.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache-config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xmlns="http://xmlns.oracle.com/coherence/coherence-cache-config"
              xmlns:spring="class://com.oracle.coherence.spring.namespace.NamespaceHandler"
              xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>xmlns:spring="class://com.oracle.coherence.spring.namespace.NamespaceHandler"</code> line declares the custom namespace,
so elements with a prefix <code>spring</code> will be handled by the <code>com.oracle.coherence.spring.namespace.NamespaceHandler</code> class.
The custom namespace handler allows us to use elements of the form <code>&lt;spring:bean&gt;bean-name&lt;/spring:bean&gt;</code> anywhere in the
configuration that Coherence normally allows an <code>&lt;instance&gt;</code> element or a <code>&lt;class-scheme&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>Thus, we can add a scheme to the <code>&lt;cache-schemes&gt;</code> section of the configuration that uses the repository bean.</p>
</div>
<div class="listingblock">
<div class="title">coherence-cache-config.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;caching-schemes&gt;
        &lt;distributed-scheme&gt;
            &lt;scheme-name&gt;db-scheme&lt;/scheme-name&gt;
            &lt;service-name&gt;StorageService&lt;/service-name&gt;
            &lt;backing-map-scheme&gt;
                &lt;read-write-backing-map-scheme&gt;
                    &lt;internal-cache-scheme&gt;
                        &lt;local-scheme/&gt;
                    &lt;/internal-cache-scheme&gt;
                    &lt;cachestore-scheme&gt;
                        &lt;spring:bean&gt;{repository-bean}&lt;/spring:bean&gt;
                    &lt;/cachestore-scheme&gt;
                &lt;/read-write-backing-map-scheme&gt;
            &lt;/backing-map-scheme&gt;
            &lt;autostart&gt;true&lt;/autostart&gt;
        &lt;/distributed-scheme&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the snippet above you can see the <code>&lt;spring:bean&gt;{repository-bean}&lt;/spring:bean&gt;</code> element used as the cache store.
In this case we have not used the name of the repository bean directly, we have used a parameter named <code>repository-bean</code>
(XML values in curly-brackets in the <code>&lt;spring:bean&gt;</code> element are treated as parameter macros). This allows us to map
multiple caches to the same scheme each with a different cache store - this is quite a common approach in Coherence for
a number of elements that may be configured in a scheme per-cache. We can now also add the cache mapping for our <code>people</code>
cache that will use the scheme above.</p>
</div>
<div class="listingblock">
<div class="title">coherence-cache-config.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">        &lt;cache-mapping&gt;
            &lt;cache-name&gt;people&lt;/cache-name&gt;
            &lt;scheme-name&gt;db-scheme&lt;/scheme-name&gt;
            &lt;init-params&gt;
                &lt;init-param&gt;
                    &lt;param-name&gt;repository-bean&lt;/param-name&gt;
                    &lt;param-value&gt;personRepository&lt;/param-value&gt;
                &lt;/init-param&gt;
            &lt;/init-params&gt;
        &lt;/cache-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the mapping above, the cache name <code>people</code> maps to the scheme <code>db-scheme</code> that we created above.
As we mentioned above, we need to pass the actual bean name in the <code>repository-bean</code> parameter, which we do by using the
<code>&lt;init-params&gt;</code> element in the mapping. We set the <code>&lt;param-value&gt;</code> element to the bean name, in this case <code>personRepository</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The bean name used here is <code>personRepository</code>. This is the default name generated by Spring for the <code>PersonRepository</code>
class, which is the simple class name with the first letter lowercase. If we did not want to rely on Spring generating a
bean name we could specify a name in the <code>@Repository</code> annotation on the <code>PersonRepository</code> class.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If we had another cache with a different cache store, for example if we had an entity called <code>Location</code> with a repository
cache store class called <code>LocationRepository</code>, the bean name would default to <code>locationRepository</code>, and we could add the
following mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache-mapping&gt;
    &lt;cache-name&gt;locations&lt;/cache-name&gt;
    &lt;scheme-name&gt;db-scheme&lt;/scheme-name&gt;
    &lt;init-params&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;repository-bean&lt;/param-name&gt;
            &lt;param-value&gt;locationRepository&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/init-params&gt;
&lt;/cache-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-running-embedded"><a class="anchor" href="#coherence-spring-cachestore-demo-running-embedded"></a>11.1.4. Running the Embedded Sample</h4>
<div class="paragraph">
<p>This sample is just a simple Spring Boot application that exposes two endpoints to create/update people and get people by id.
The controller class for the two endpoints is very simple:</p>
</div>
<div class="listingblock">
<div class="title">PersonController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@RequestMapping(path = "/api/people")
@Transactional()
public class PersonController {

    /**
     * The {@link NamedMap} to store {@link Person} entities.
     */
    @CoherenceMap
    private NamedMap&lt;Long, Person&gt; people;

    @Autowired
    private PersonRepository personRepository;

    /**
     * Create a {@link Person} in the cache.
     * @param id         the unique identifier for the person
     * @param firstName  the person's first name
     * @param lastName   the person's last name
     * @param age        the person's age
     * @return the identifier used to create the person
     */
    @PostMapping
    public Long createPerson(@RequestParam("id") long id, @RequestParam("firstName") String firstName,
            @RequestParam("lastName") String lastName, @RequestParam("age") int age) {
        Person person = new Person();
        person.setFirstname(firstName);
        person.setLastname(lastName);
        person.setAge(age);
        person.setId(id);
        people.put(id, person);
        return id;
    }

    /**
     * Returns the {@link Person} with the specified identifier.
     *
     * @param personId  the unique identifier for the person
     * @return  the {@link Person} with the specified identifier
     */
    @GetMapping("/{personId}")
    public Person getPerson(@PathVariable("personId") Long personId) {
        Person person = people.get(personId);
        if (person == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Person " + personId + " does not exist");
        }
        return person;
    }

    @GetMapping("/db/{personId}")
    public Person getPersonFromDb(@PathVariable("personId") Long personId) {
        Person person = this.personRepository.findById(personId).orElseThrow(() -&gt; {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Person " + personId + " does not exist");
        });
        return person;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the Coherence Spring integration to inject a <code>NamedMap</code> into the controller. This will be for the cache named <code>people</code>,
which we configured to use the cache store in the configuration above.</p>
</div>
<div class="paragraph">
<p>In the <code>createPerson</code> method we use the request parameters to create a <code>Person</code> and put it into the cache. The <code>CacheStore</code>
will write this to the database.</p>
</div>
<div class="paragraph">
<p>In the <code>getPerson</code> method we retrieve the <code>Person</code> from the cache using the id from the request path, loading from the
database if there is no entry in the cache for the id.</p>
</div>
<div class="paragraph">
<p>We can build the example using Maven from the root directory of Coherence Spring:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw clean package -pl samples/cachestore-demo</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will build a Spring Boot jar that we can run the normal Spring Boot ways, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar samples/cachestore-demo/coherence-spring-cachestore-demo-app/target/coherence-spring-cachestore-demo-4.0.0-SNAPSHOT.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the application has started we can try to get a <code>Person</code> using <code>curl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -i -X GET http://localhost:8080/api/people/100</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should return a 404 response because there is no person in the database or cache with the id 100.</p>
</div>
<div class="paragraph">
<p>We can create a <code>Person</code> using a <code>curl</code> POST request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -i -X POST http://localhost:8080/api/people \
    -d 'firstName=Joe' -d 'lastName=Smith' \
    -d 'age=21' -d 'id=100'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create the <code>Person</code> named Joe Smith with the id 100. This should return with a 200 response to say the <code>Person</code>
was successfully created and will be stored in the database.</p>
</div>
<div class="paragraph">
<p>If we re-run the GET request we should get Joe Smith.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -i -X GET http://localhost:8080/api/people/100
HTTP/1.1 200
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 19 Aug 2021 16:13:47 GMT

{"id":100,"age":21,"firstname":"Joe","lastname":"Smith"}%</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-coherence-extend"><a class="anchor" href="#coherence-spring-cachestore-demo-coherence-extend"></a>11.1.5. Using Coherence*Extend</h4>
<div class="paragraph">
<p>This is the slightly more complex version of the CacheStore demo. Instead of using an embedded version Coherence, we
will have a remote Coherence instance and the actual application will connect to Coherence via Coherence*Extend.</p>
</div>
<div class="paragraph">
<p>We can build the example using Maven from the root directory of Coherence Spring:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw clean install -pl :coherence-spring-cachestore-demo-server -am -DskipTests
./mvnw clean install -pl :coherence-spring-cachestore-demo-app -am -DskipTests</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have to start the Coherence Server as well as the Coherence Client App. We run both apps using Spring Boot. Let&#8217;s
start with the Coherence Server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar samples/cachestore-demo/coherence-spring-cachestore-demo-server/target/coherence-spring-cachestore-demo-server-4.0.0-SNAPSHOT.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we start the client app. It is actually the same app as used in the embedded Coherence use-case. However, we will
specify an additional Spring Boot profile, instructing the app to connect to the Coherence server in client mode via
Coherence*Extend:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar samples/cachestore-demo/coherence-spring-cachestore-demo-app/target/coherence-spring-cachestore-demo-app-4.0.0-SNAPSHOT.jar \
--Dspring.profiles.active=remote</code></pre>
</div>
</div>
<div class="paragraph">
<p>By activating the <code>remote</code> Spring Boot profile, we will configure Coherence for client mode and we reference a different
Cache Configuration XML file called <code>remote-cache-config.xml</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="coherence-spring-cachestore-demo-inspect-database"><a class="anchor" href="#coherence-spring-cachestore-demo-inspect-database"></a>11.1.6. Inspecting the Database</h4>
<div class="paragraph">
<p>In the remote Coherence CacheStore demo, HSQL will be instantiated via the server module. This allow the app as well as
the server to access the HSQL database instance. That way we can also inspect
the data in the data more easily as we can inspect the database data via SQL tools
such as the open-source <a href="https://dbeaver.io/">DBeaver</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-04-27 05:24:53 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>